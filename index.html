<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="天道酬勤">
<meta property="og:type" content="website">
<meta property="og:title" content="朝花夕拾">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="朝花夕拾">
<meta property="og:description" content="天道酬勤">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="朝花夕拾">
<meta name="twitter:description" content="天道酬勤">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>朝花夕拾</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">朝花夕拾</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/26/React-Brith-Death/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="踽踽前行的路人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/26/React-Brith-Death/" itemprop="url">React的前世今生</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-26T17:25:02+08:00">
                2018-01-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="React的基本操作"><a href="#React的基本操作" class="headerlink" title="React的基本操作"></a>React的基本操作</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">'prop-types'</span>;</div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;button style=&#123;&#123;<span class="attr">background</span>: <span class="keyword">this</span>.context.color&#125;&#125;&gt;</div><div class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</div><div class="line">      &lt;<span class="regexp">/button&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">Button.contextTypes = &#123;</span></div><div class="line"><span class="regexp">  color: PropTypes.string</span></div><div class="line"><span class="regexp">&#125;;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">class Message extends React.Component &#123;</span></div><div class="line"><span class="regexp">  render() &#123;</span></div><div class="line"><span class="regexp">    return (</span></div><div class="line"><span class="regexp">      &lt;div&gt;</span></div><div class="line"><span class="regexp">        &#123;this.props.text&#125; &lt;Button&gt;Delete&lt;/</span>Button&gt;</div><div class="line">      &lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">    );</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp">&#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">class MessageList extends React.Component &#123;</span></div><div class="line"><span class="regexp">    /</span>**构造函数的使用，ES6为了模仿JAVA,C++等oop的对象继承方式</div><div class="line">        <span class="number">1.</span>在组件未加载之前调用</div><div class="line">        <span class="number">2.</span>调用<span class="keyword">super</span>(props)用于props的初始化</div><div class="line">        <span class="number">3.</span>初始化组件State</div><div class="line">    **<span class="regexp">/</span></div><div class="line"><span class="regexp">    constructor(props,context) &#123;</span></div><div class="line"><span class="regexp">    super(props);</span></div><div class="line"><span class="regexp">    this.state = &#123; &#125;;</span></div><div class="line"><span class="regexp">    &#125;</span></div><div class="line"><span class="regexp">    /</span><span class="regexp">/定义组件的默认属性</span></div><div class="line"><span class="regexp">     static defaultProps = &#123;</span></div><div class="line"><span class="regexp">    name: 'stranger'</span></div><div class="line"><span class="regexp">  &#125;</span></div><div class="line"><span class="regexp"></span></div><div class="line"><span class="regexp">    /</span>**</div><div class="line">    <span class="number">1.</span>render()函数调用之前</div><div class="line">    <span class="number">2.</span>用于服务端渲染使用</div><div class="line">    <span class="number">3.</span>(同步)调用setState会不会触发render()，但是state中的值会发生变化</div><div class="line">    **<span class="regexp">/</span></div><div class="line"><span class="regexp">    componentWillMount()&#123;&#125;</span></div><div class="line"><span class="regexp">    render() &#123;</span></div><div class="line"><span class="regexp">    const children = this.props.messages.map((message) =&gt;</span></div><div class="line"><span class="regexp">      &lt;Message text=&#123;message.text&#125; /</span>&gt;</div><div class="line">    );</div><div class="line">    <span class="keyword">return</span> &lt;div&gt;&#123;children&#125;&lt;/div&gt;;</div><div class="line">   &#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    在组件加载完调用(render()调用完，被调用)</span></div><div class="line"><span class="comment">    1.此处可以获取到DOM节点(如果需要操作真实DOM的话)</span></div><div class="line"><span class="comment">    2.网络请求</span></div><div class="line"><span class="comment">    3.调用setState会触发render()</span></div><div class="line"><span class="comment">    **/</span></div><div class="line">    componentDidMount()&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    1.被加载组件接收到新的props被调用</span></div><div class="line"><span class="comment">    2.调用setState会触发render()。。。。。如果调用setState的话，需要进行数据对比</span></div><div class="line"><span class="comment">      对于简单的值，可以比较this.props.X === nextProps.X，但是对于复杂数据类型(Object来讲)需要进行深度对比(利用loadsh/immuable)</span></div><div class="line"><span class="comment">    **/</span></div><div class="line">    componentWillReceiveProps(nextProps, nextContext)&#123;&#125;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    1.用于进行不必要的渲染</span></div><div class="line"><span class="comment">    如果props,state的变化不是想要的，可以根据该方法来进行阻止渲染 return false;</span></div><div class="line"><span class="comment">    2.不能调用setState()</span></div><div class="line"><span class="comment">    **/</span></div><div class="line">    shouldComponentUpdate(nextProps, nextState, nextContext)</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    1.在组件获取新的state/props 且在render()之前发生</span></div><div class="line"><span class="comment">    2.不能调用setState()回发生死循环</span></div><div class="line"><span class="comment">    **/</span></div><div class="line">    componentWillUpdate(nextProps, nextState, nextContext)</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">    1.如果组件中设计了Context,该方法用于初始化context中的值</span></div><div class="line"><span class="comment">    **/</span></div><div class="line">    getChildContext() &#123;</div><div class="line">        <span class="keyword">return</span> &#123;<span class="attr">color</span>: <span class="string">"purple"</span>&#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">  </div><div class="line">&#125;</div><div class="line"><span class="comment">//定义Context的属性，并规定类型</span></div><div class="line">MessageList.childContextTypes = &#123;</div><div class="line">  color: PropTypes.string</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码是采用React1.6版本所写，有一些属性的处理方式和1.5版本有点不一样</p>
<blockquote>
<p>组件的PropTypes不在React库中维护，单独用prop-types维护</p>
</blockquote>
<h1 id="React源码分析"><a href="#React源码分析" class="headerlink" title="React源码分析"></a>React源码分析</h1><p><a href="">源码地址</a><a href="https://github.com/facebook/react/releases" target="_blank" rel="external">https://github.com/facebook/react/releases</a></p>
<h2 id="React-Componet的实现"><a href="#React-Componet的实现" class="headerlink" title="React.Componet的实现"></a>React.Componet的实现</h2><p>在进行React页面开发的时候，需要进行一次继承<strong>class personComponet extends React.Component</strong>,这里涉及到React库中的<strong>Component</strong>。在该函数中定义了一些<strong>自定义组件</strong>需要用的<em>props/context/refs/updater</em>。其中props很简单，context的话，和props的作用类型，refs是获取组件的<strong>引用</strong>。而updater来讲，是用于更新组件的状态(触发组件的render())。<br>//react\packages\react\src\ReactBaseClasses.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> ReactNoopUpdateQueue <span class="keyword">from</span> <span class="string">'./ReactNoopUpdateQueue'</span>;<span class="comment">//用于state信息的处理</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Base class helpers for the updating state of a component.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Component</span>(<span class="params">props, context, updater</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.props = props;</div><div class="line">  <span class="keyword">this</span>.context = context;</div><div class="line">  <span class="keyword">this</span>.refs = emptyObject;</div><div class="line">  <span class="comment">// We initialize the default updater but the real one gets injected by the</span></div><div class="line">  <span class="comment">// renderer.</span></div><div class="line">  <span class="keyword">this</span>.updater = updater || ReactNoopUpdateQueue;</div><div class="line">&#125;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Sets a subset of the state. Always use this to mutate</span></div><div class="line"><span class="comment"> * state. You should treat `this.state` as immutable.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * There is no guarantee that `this.state` will be immediately updated, so</span></div><div class="line"><span class="comment"> * accessing `this.state` after calling this method may return the old value.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * There is no guarantee that calls to `setState` will run synchronously,</span></div><div class="line"><span class="comment"> * as they may eventually be batched together.  You can provide an optional</span></div><div class="line"><span class="comment"> * callback that will be executed when the call to setState is actually</span></div><div class="line"><span class="comment"> * completed.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * When a function is provided to setState, it will be called at some point in</span></div><div class="line"><span class="comment"> * the future (not synchronously). It will be called with the up to date</span></div><div class="line"><span class="comment"> * component arguments (state, props, context). These values can be different</span></div><div class="line"><span class="comment"> * from this.* because your function may be called after receiveProps but before</span></div><div class="line"><span class="comment"> * shouldComponentUpdate, and this new state, props, and context will not yet be</span></div><div class="line"><span class="comment"> * assigned to this.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param &#123;object|function&#125; partialState Next partial state or function to</span></div><div class="line"><span class="comment"> *        produce next partial state to be merged with current state.</span></div><div class="line"><span class="comment"> * @param &#123;?function&#125; callback Called after state is updated.</span></div><div class="line"><span class="comment"> * @final</span></div><div class="line"><span class="comment"> * @protected</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Component.prototype.setState = <span class="function"><span class="keyword">function</span>(<span class="params">partialState, callback</span>) </span>&#123;</div><div class="line">  invariant(</div><div class="line">    <span class="keyword">typeof</span> partialState === <span class="string">'object'</span> ||</div><div class="line">      <span class="keyword">typeof</span> partialState === <span class="string">'function'</span> ||</div><div class="line">      partialState == <span class="literal">null</span>,</div><div class="line">    <span class="string">'setState(...): takes an object of state variables to update or a '</span> +</div><div class="line">      <span class="string">'function which returns an object of state variables.'</span>,</div><div class="line">  );</div><div class="line">  <span class="keyword">this</span>.updater.enqueueSetState(<span class="keyword">this</span>, partialState, callback, <span class="string">'setState'</span>);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Forces an update. This should only be invoked when it is known with</span></div><div class="line"><span class="comment"> * certainty that we are **not** in a DOM transaction.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * You may want to call this when you know that some deeper aspect of the</span></div><div class="line"><span class="comment"> * component's state has changed but `setState` was not called.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This will not invoke `shouldComponentUpdate`, but it will invoke</span></div><div class="line"><span class="comment"> * `componentWillUpdate` and `componentDidUpdate`.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param &#123;?function&#125; callback Called after update is complete.</span></div><div class="line"><span class="comment"> * @final</span></div><div class="line"><span class="comment"> * @protected</span></div><div class="line"><span class="comment"> */</span></div><div class="line">Component.prototype.forceUpdate = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.updater.enqueueForceUpdate(<span class="keyword">this</span>, callback, <span class="string">'forceUpdate'</span>);</div><div class="line">&#125;;</div><div class="line"><span class="keyword">export</span> &#123; Component&#125;;</div></pre></td></tr></table></figure></p>
<p>这里需要简单介绍一下，上述代码有一定的删减，删除了针对 <strong>AsyncComponent/PureComponent</strong>的处理</p>
<ol>
<li>在定义Component对象的必要的props/context/refs/updater等属性</li>
<li>在对象的prototype定义必要的更新方法(setState/forceUpdate),同时在enqueueForceUpdate中注册事件</li>
<li>enqueueForceUpdate用于记录组件<strong>更新操作</strong></li>
</ol>
<h2 id="组件定义页面结构"><a href="#组件定义页面结构" class="headerlink" title="组件定义页面结构"></a>组件定义页面结构</h2><p>在页面开发过程中，是利用JSX来进行UI的构建。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;MyButton color=<span class="string">"blue"</span> shadowSize=&#123;<span class="number">2</span>&#125;&gt;</div><div class="line">  Click Me</div><div class="line">&lt;<span class="regexp">/MyButton&gt;</span></div></pre></td></tr></table></figure></p>
<p>也就是构建的代码和ui是一一对应的关系。<br>基于原生开发中html在最后页面的呈现的阶段会被DOM Parse解析为DOM Tree。同理，在进行JSX页面构建的时候，最后也是会被构建为<strong>对象</strong>。并且这个对象和DOM Parse针对html的操作处理生成的DOM是对应的。该对象被称为<strong>Virtual DOM</strong>。<br>在JSX变成Virtual DOM的过程中，有一个过客为<strong>createElement</strong>。<br>其实上面的代码在React内部会被<em>解释</em>为<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">React.createElement(</div><div class="line">  MyButton,</div><div class="line">  &#123;<span class="attr">color</span>: <span class="string">'blue'</span>, <span class="attr">shadowSize</span>: <span class="number">2</span>&#125;,</div><div class="line">  <span class="string">'Click Me'</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>也就是说在利用JSX对页面进行结构的构建，在被渲染为DOM之前被会<strong>React.createElement</strong>解析为一个对象。换句话来将，就是JSX构建的UI只是为了代码和UI结构匹配，最终让React识别的是由createElement处理过的代码。</p>
<h3 id="React-createElement方法处理"><a href="#React-createElement方法处理" class="headerlink" title="React.createElement方法处理"></a>React.createElement方法处理</h3><p>//react\packages\react\src\ReactElement.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Create and return a new ReactElement of the given type.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> propName;</div><div class="line"></div><div class="line">  <span class="comment">// Reserved names are extracted(保存config中指定的属性)</span></div><div class="line">  <span class="keyword">const</span> props = &#123;&#125;;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> key = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">let</span> ref = <span class="literal">null</span>;</div><div class="line">   </div><div class="line">  <span class="keyword">if</span> (config != <span class="literal">null</span>) &#123;</div><div class="line">    <span class="comment">//判断元素是否存在ref</span></div><div class="line">    <span class="keyword">if</span> (hasValidRef(config)) &#123;</div><div class="line">      ref = config.ref;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//判断是否存在key</span></div><div class="line">    <span class="keyword">if</span> (hasValidKey(config)) &#123;</div><div class="line">      key = <span class="string">''</span> + config.key;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Remaining properties are added to a new props object</span></div><div class="line">    <span class="comment">//处理config中属性，保存在props中。</span></div><div class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> config) &#123;</div><div class="line">      <span class="keyword">if</span> (</div><div class="line">        hasOwnProperty.call(config, propName) &amp;&amp;</div><div class="line">        !RESERVED_PROPS.hasOwnProperty(propName)</div><div class="line">      ) &#123;</div><div class="line">        props[propName] = config[propName];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// Children can be more than one argument, and those are transferred onto</span></div><div class="line">  <span class="comment">// the newly allocated props object.</span></div><div class="line">  <span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;<span class="comment">//从argument中获取子元素的个数</span></div><div class="line">  <span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123;</div><div class="line">    props.children = children;</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123;</div><div class="line">    <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength);</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123;</div><div class="line">      childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</div><div class="line">    &#125;</div><div class="line">    props.children = childArray;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">/**</span></div><div class="line"><span class="comment">    在组件定义的时候，可以用defaultProps进行组件默认属性的指定</span></div><div class="line"><span class="comment">    </span></div><div class="line"><span class="comment">  **/</span></div><div class="line">  <span class="comment">// Resolve default props</span></div><div class="line">  <span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</div><div class="line">    <span class="keyword">const</span> defaultProps = type.defaultProps;</div><div class="line">    <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123;</div><div class="line">      <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</div><div class="line">        props[propName] = defaultProps[propName];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//调用ReactElement Factory进行组件的真正构建</span></div><div class="line">  <span class="keyword">return</span> ReactElement(</div><div class="line">    type,</div><div class="line">    key,</div><div class="line">    ref,</div><div class="line">    self,</div><div class="line">    source,</div><div class="line">    ReactCurrentOwner.current,</div><div class="line">    props,</div><div class="line">  );</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="ReactElement-Factory分析"><a href="#ReactElement-Factory分析" class="headerlink" title="ReactElement Factory分析"></a>ReactElement Factory分析</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Factory method to create a new React element. This no longer adheres to</span></div><div class="line"><span class="comment"> * the class pattern, so do not use new to call it. Also, no instanceof check</span></div><div class="line"><span class="comment"> * will work. Instead test $$typeof field against Symbol.for('react.element') to check</span></div><div class="line"><span class="comment"> * if something is a React Element.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param &#123;*&#125; type</span></div><div class="line"><span class="comment"> * @param &#123;*&#125; key</span></div><div class="line"><span class="comment"> * @param &#123;string|object&#125; ref</span></div><div class="line"><span class="comment"> * @param &#123;*&#125; self A *temporary* helper to detect places where `this` is</span></div><div class="line"><span class="comment"> * different from the `owner` when React.createElement is called, so that we</span></div><div class="line"><span class="comment"> * can warn. We want to get rid of owner and replace string `ref`s with arrow</span></div><div class="line"><span class="comment"> * functions, and as long as `this` and owner are the same, there will be no</span></div><div class="line"><span class="comment"> * change in behavior.</span></div><div class="line"><span class="comment"> * @param &#123;*&#125; source An annotation object (added by a transpiler or otherwise)</span></div><div class="line"><span class="comment"> * indicating filename, line number, and/or other information.</span></div><div class="line"><span class="comment"> * @param &#123;*&#125; owner</span></div><div class="line"><span class="comment"> * @param &#123;*&#125; props</span></div><div class="line"><span class="comment"> * @internal</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> ReactElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> element = &#123;</div><div class="line">    <span class="comment">// This tag allow us to uniquely identify this as a React Element</span></div><div class="line">    $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,<span class="comment">//采用ES6的Symbol进行element的处理</span></div><div class="line"></div><div class="line">    <span class="comment">// Built-in properties that belong on the element</span></div><div class="line">    type: type,</div><div class="line">    key: key,</div><div class="line">    ref: ref,</div><div class="line">    props: props,</div><div class="line"></div><div class="line">    <span class="comment">// Record the component responsible for creating this element.</span></div><div class="line">    _owner: owner,</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> element;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>其实针对Factory就是一个简单的传入传出。</p>
<h2 id="组件挂载页面"><a href="#组件挂载页面" class="headerlink" title="组件挂载页面"></a>组件挂载页面</h2><p>在利用JSX构建了页面的组织结构(内部采用React.createElement进行元素的处理)，现在需要将<strong>element</strong>进行<strong>挂载</strong>到<strong>Virtual DOM</strong>中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloMessage</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> &lt;div&gt;Hello &#123;this.props.name&#125;&lt;/div&gt;;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//进行组件的渲染(mount阶段)</span></div><div class="line">ReactDOM.render(</div><div class="line">  &lt;HelloMessage name=<span class="string">"John"</span> /&gt;,</div><div class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'container'</span>)</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>在利用JSX将UI结构构建完成之后，就需要将组件<strong>挂载</strong>到DOM上。<br><a href="https://reactjs.org/docs/react-dom.html#overview" target="_blank" rel="external">ReactDOM.render()</a>用于将组件挂载到DOM<br>在react-dom库中，ReactDOM和React一样，就是一个简单对象，内置很多属性，其中<strong>render()</strong>就是用于渲染的。<br>//react-dom\lib\ReactDOM.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> ReactMount = <span class="built_in">require</span>(<span class="string">'./ReactMount'</span>);</div><div class="line"><span class="keyword">var</span> findDOMNode = <span class="built_in">require</span>(<span class="string">'./findDOMNode'</span>);</div><div class="line"><span class="keyword">var</span> ReactDOM = &#123;</div><div class="line">  findDOMNode: findDOMNode,</div><div class="line">  render: ReactMount.render,</div><div class="line">&#125;;</div><div class="line"><span class="built_in">module</span>.exports = ReactDOM;</div></pre></td></tr></table></figure></p>
<p>上面代码有一定的删减，只是留下来开发中用到的。可以看到在ReactDOM.render()中render属性是由ReactMount中定义的。<br>react-dom\lib\ReactMount.js</p>
<h3 id="ReactDOM-render-解析"><a href="#ReactDOM-render-解析" class="headerlink" title="ReactDOM.render()解析"></a>ReactDOM.render()解析</h3><p>在进行ReactDOM.render()操作的时候，是调用的ReactMount中的render()</p>
<h4 id="ReactMount-render-分析"><a href="#ReactMount-render-分析" class="headerlink" title="ReactMount.render()分析"></a>ReactMount.render()分析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">  * Renders a React component into the DOM in the supplied `container`.</span></div><div class="line"><span class="comment">  *</span></div><div class="line"><span class="comment">  * If the React component was previously rendered into `container`, this will</span></div><div class="line"><span class="comment">  * perform an update on it and only mutate the DOM as necessary to reflect the</span></div><div class="line"><span class="comment">  * latest React component.</span></div><div class="line"><span class="comment">  *</span></div><div class="line"><span class="comment">  * @param &#123;ReactElement&#125; nextElement Component element to render.</span></div><div class="line"><span class="comment">  * @param &#123;DOMElement&#125; container DOM element to render into.</span></div><div class="line"><span class="comment">  * @param &#123;?function&#125; callback function triggered on completion</span></div><div class="line"><span class="comment">  * @return &#123;ReactComponent&#125; Component instance rendered in `container`.</span></div><div class="line"><span class="comment">  */</span></div><div class="line"> render: <span class="function"><span class="keyword">function</span> (<span class="params">nextElement, container, callback</span>) </span>&#123;</div><div class="line">   <span class="keyword">return</span> ReactMount._renderSubtreeIntoContainer(<span class="literal">null</span>, nextElement, container, callback);</div><div class="line"> &#125;,</div></pre></td></tr></table></figure>
<h4 id="ReactMount-renderSubtreeIntoContainer-分析"><a href="#ReactMount-renderSubtreeIntoContainer-分析" class="headerlink" title="ReactMount._renderSubtreeIntoContainer()分析"></a>ReactMount._renderSubtreeIntoContainer()分析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">_renderSubtreeIntoContainer: <span class="function"><span class="keyword">function</span> (<span class="params">parentComponent, nextElement, container, callback</span>) </span>&#123;</div><div class="line">  <span class="comment">/**TopLevelWrapper这里只是一个临时的数据项，</span></div><div class="line"><span class="comment">  var topLevelRootCounter = 1;</span></div><div class="line"><span class="comment">  var TopLevelWrapper = function () &#123;</span></div><div class="line"><span class="comment">    this.rootID = topLevelRootCounter++;</span></div><div class="line"><span class="comment">  &#125;;</span></div><div class="line"><span class="comment">  **/</span></div><div class="line">  <span class="comment">//主要目的就是根据nextElement来构建对象</span></div><div class="line">  <span class="keyword">var</span> nextWrappedElement = React.createElement(TopLevelWrapper, &#123;</div><div class="line">    child: nextElement</div><div class="line">  &#125;);</div><div class="line">  <span class="comment">//在React Virtual DOM中获取container的实例。</span></div><div class="line">  <span class="keyword">var</span> prevComponent = getTopLevelWrapperInContainer(container);</div><div class="line">  <span class="comment">//如果存在的话，说明该组件已经被实例化在DOM树上，所以该render属于更新阶段</span></div><div class="line">  <span class="keyword">if</span> (prevComponent) &#123;</div><div class="line">    <span class="keyword">var</span> prevWrappedElement = prevComponent._currentElement;</div><div class="line">    <span class="keyword">var</span> prevElement = prevWrappedElement.props.child;</div><div class="line">    <span class="keyword">if</span> (shouldUpdateReactComponent(prevElement, nextElement)) &#123;</div><div class="line">      <span class="keyword">var</span> publicInst = prevComponent._renderedComponent.getPublicInstance();</div><div class="line">      <span class="keyword">var</span> updatedCallback = callback &amp;&amp; <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        callback.call(publicInst);</div><div class="line">      &#125;;</div><div class="line">      ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);</div><div class="line">      <span class="keyword">return</span> publicInst;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      ReactMount.unmountComponentAtNode(container);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">    <span class="keyword">var</span> component = ReactMount._renderNewRootComponent(nextWrappedElement, container, nextContext)._renderedComponent.getPublicInstance();</div><div class="line">  <span class="keyword">return</span> component;</div><div class="line">&#125;,</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Render a new component into the DOM. Hooked by hooks!</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param &#123;ReactElement&#125; nextElement element to render</span></div><div class="line"><span class="comment"> * @param &#123;DOMElement&#125; container container to render into</span></div><div class="line"><span class="comment"> * @return &#123;ReactComponent&#125; nextComponent</span></div><div class="line"><span class="comment"> */</span></div><div class="line">_renderNewRootComponent: <span class="function"><span class="keyword">function</span> (<span class="params">nextElement, container, context</span>) </span>&#123;</div><div class="line">  <span class="comment">//实例化组件(将nextElement挂载到DOM中)</span></div><div class="line">  <span class="keyword">var</span> componentInstance = instantiateReactComponent(nextElement, <span class="literal">false</span>);</div><div class="line"></div><div class="line">  <span class="comment">// The initial render is synchronous but any updates that happen during</span></div><div class="line">  <span class="comment">// rendering, in componentWillMount or componentDidMount, will be batched</span></div><div class="line">  <span class="comment">// according to the current batching strategy.</span></div><div class="line">  <span class="comment">//这里利用批处理来进行组件的更新操作</span></div><div class="line">  ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, context);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> componentInstance;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>上面的代码需要有一个地方，就是在进行批处理的时候，内部有有一套比较机制用于进行组件的<a href="https://zhuanlan.zhihu.com/p/20328570" target="_blank" rel="external">高效更新</a></p>
<h2 id="Buzzer"><a href="#Buzzer" class="headerlink" title="Buzzer"></a>Buzzer</h2><p>其实针对React中Element/Component渲染到真正的DOM上，需要很多过程。<br>针对React这个库，就是定义了一些组件中的<a href="https://reactjs.org/docs/react-component.html" target="_blank" rel="external">生命周期</a>/Context/State等<br>而涉及到加载/更新/卸载等操作都是在ReactDOM中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/24/React-Router-Acquaintance/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="踽踽前行的路人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/24/React-Router-Acquaintance/" itemprop="url">初识React-Router</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-24T22:54:35+08:00">
                2018-01-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="React-Router基本了解"><a href="#React-Router基本了解" class="headerlink" title="React-Router基本了解"></a>React-Router基本了解</h1><p>对于React-Router是针对React定义的路由库，用于将URL和component进行匹配。<br><a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html?utm_source=tool.lu" target="_blank" rel="external">React Router的简单使用教程</a></p>
<h1 id="React-Router源码分析"><a href="#React-Router源码分析" class="headerlink" title="React-Router源码分析"></a>React-Router源码分析</h1><h2 id="简单前端路由的实现"><a href="#简单前端路由的实现" class="headerlink" title="简单前端路由的实现"></a>简单前端路由的实现</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>router<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/"</span>&gt;</span>turn white<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/blue"</span>&gt;</span>turn blue<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#/green"</span>&gt;</span>turn green<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span> </div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">Router</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.routes = &#123;&#125;;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.currentUrl = <span class="string">''</span>;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="undefined">    &lt;!--</span></div><div class="line"><span class="javascript">    <span class="comment">//针对不同的地址进行回调的匹配</span></span></div><div class="line"><span class="javascript">    <span class="comment">//1:用户在调用Router.route('address',function),在this.routes对象中进行记录或者说address与function的匹配</span></span></div><div class="line"><span class="undefined">    --&gt;</span></div><div class="line"><span class="javascript">    Router.prototype.route = <span class="function"><span class="keyword">function</span>(<span class="params">path, callback</span>) </span>&#123;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.routes[path] = callback || <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span></div><div class="line"><span class="undefined">    &#125;;</span></div><div class="line"><span class="undefined">    &lt;!--</span></div><div class="line"><span class="javascript">    <span class="comment">//处理hash的变化，针对不同的值，进行页面的处理</span></span></div><div class="line"><span class="javascript">    <span class="comment">//1:在init中注册过事件，在页面load的时候，进行页面的处理</span></span></div><div class="line"><span class="javascript">    <span class="comment">//2：在hashchange变化时，进行页面的处理</span></span></div><div class="line"><span class="undefined">    --&gt;</span></div><div class="line"><span class="javascript">    Router.prototype.refresh = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.currentUrl = location.hash.slice(<span class="number">1</span>) || <span class="string">'/'</span>;</span></div><div class="line"><span class="javascript">        <span class="keyword">this</span>.routes[<span class="keyword">this</span>.currentUrl]();</span></div><div class="line"><span class="undefined">    &#125;;</span></div><div class="line"><span class="undefined">    &lt;!--</span></div><div class="line"><span class="javascript">    <span class="comment">//1：在Router的prototype中定义init</span></span></div><div class="line"><span class="javascript">    <span class="comment">//2：在页面load/hashchange事件触发时，进行回调处理</span></span></div><div class="line"><span class="javascript">    <span class="comment">//3：利用addEventListener来添加事件，注意第三个参数的用处</span></span></div><div class="line"><span class="javascript">    <span class="comment">//4：bind的使用区别于apply/call的使用</span></span></div><div class="line"><span class="undefined">    --&gt;</span></div><div class="line"><span class="javascript">    Router.prototype.init = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span></div><div class="line"><span class="javascript">        <span class="built_in">window</span>.addEventListener(<span class="string">'hashchange'</span>, <span class="keyword">this</span>.refresh.bind(<span class="keyword">this</span>), <span class="literal">false</span>);</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="javascript">    <span class="built_in">window</span>.Router = <span class="keyword">new</span> Router();<span class="comment">//在window对象中构建一个Router对象</span></span></div><div class="line"><span class="javascript">    <span class="built_in">window</span>.Router.init();<span class="comment">//页面初始化处理</span></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> content = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>);</span></div><div class="line"><span class="javascript">    <span class="comment">// change Page anything</span></span></div><div class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">changeBgColor</span>(<span class="params">color</span>) </span>&#123;</span></div><div class="line"><span class="undefined">        content.style.backgroundColor = color;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="javascript">    Router.route(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        changeBgColor(<span class="string">'white'</span>);</span></div><div class="line"><span class="undefined">    &#125;);</span></div><div class="line"><span class="javascript">    Router.route(<span class="string">'/blue'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        changeBgColor(<span class="string">'blue'</span>);</span></div><div class="line"><span class="undefined">    &#125;);</span></div><div class="line"><span class="javascript">    Router.route(<span class="string">'/green'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></div><div class="line"><span class="javascript">        changeBgColor(<span class="string">'green'</span>);</span></div><div class="line"><span class="undefined">    &#125;);</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>上面的路由系统主要由三部分组成</p>
<ol>
<li>Router.protopyte.init 用于页面初始化(load)/页面url变化  的事件注册</li>
<li>Router.protopyte.route 对路径(address)和回调函数(function)的注册并存放于Router中，为load/hashchange使用</li>
<li>Router.protopyte.refresh 针对不同的路径(address)进行回调的处理</li>
</ol>
<h2 id="React-Router简单实现"><a href="#React-Router简单实现" class="headerlink" title="React-Router简单实现"></a>React-Router简单实现</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>包装方式<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">	<span class="keyword">var</span> body = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>),</span></div><div class="line"><span class="javascript">		newNode = <span class="literal">null</span>,</span></div><div class="line"><span class="javascript">        append = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span></div><div class="line"><span class="javascript">    		newNode = <span class="built_in">document</span>.createElement(<span class="string">"p"</span>);</span></div><div class="line"><span class="undefined">    		newNode.innerHTML = str;</span></div><div class="line"><span class="undefined">    		body.appendChild(newNode);</span></div><div class="line"><span class="undefined">    	&#125;;</span></div><div class="line"><span class="undefined">	</span></div><div class="line"><span class="javascript">    <span class="comment">// 原对象（这里可以是H5的history对象）</span></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> historyModule = &#123;</span></div><div class="line"><span class="undefined">        listener: [],</span></div><div class="line"><span class="javascript">        listen: <span class="function"><span class="keyword">function</span> (<span class="params">listener</span>) </span>&#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">this</span>.listener.push(listener);</span></div><div class="line"><span class="javascript">            append(<span class="string">'historyModule listen.'</span>)</span></div><div class="line"><span class="undefined">        &#125;,</span></div><div class="line"><span class="javascript">        updateLocation: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></div><div class="line"><span class="javascript">            append(<span class="string">'historyModule updateLocation tirgger.'</span>);</span></div><div class="line"><span class="javascript">            <span class="keyword">this</span>.listener.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">listener</span>)</span>&#123;</span></div><div class="line"><span class="javascript">                listener(<span class="string">'new localtion'</span>);</span></div><div class="line"><span class="undefined">            &#125;)</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="javascript">    <span class="comment">// Router 将使用 historyModule 对象，并对其包装</span></span></div><div class="line"><span class="javascript">    <span class="keyword">var</span> Router = &#123;</span></div><div class="line"><span class="undefined">        source: &#123;&#125;,</span></div><div class="line"><span class="javascript">        <span class="comment">//复制historyModule到Router中</span></span></div><div class="line"><span class="javascript">        init: <span class="function"><span class="keyword">function</span>(<span class="params">source</span>)</span>&#123;</span></div><div class="line"><span class="javascript">            <span class="keyword">this</span>.source = source;</span></div><div class="line"><span class="undefined">        &#125;,</span></div><div class="line"><span class="javascript">        <span class="comment">//处理监听事件，在Router对页面进行处理时，利用historyModule中处理页面</span></span></div><div class="line"><span class="javascript">        listen: <span class="function"><span class="keyword">function</span>(<span class="params">listener</span>) </span>&#123;</span></div><div class="line"><span class="javascript">            append(<span class="string">'Router listen.'</span>);</span></div><div class="line"><span class="javascript">            <span class="comment">// 对 historyModule的listen进行了一层包装</span></span></div><div class="line"><span class="javascript">            <span class="keyword">return</span> <span class="keyword">this</span>.source.listen(<span class="function"><span class="keyword">function</span>(<span class="params">location</span>)</span>&#123;</span></div><div class="line"><span class="javascript">                append(<span class="string">'Router listen tirgger.'</span>);</span></div><div class="line"><span class="undefined">                listener(location);</span></div><div class="line"><span class="undefined">            &#125;)</span></div><div class="line"><span class="undefined">        &#125;</span></div><div class="line"><span class="undefined">    &#125;</span></div><div class="line"><span class="javascript">    <span class="comment">// 将 historyModule 注入进 Router 中</span></span></div><div class="line"><span class="undefined">    Router.init(historyModule);</span></div><div class="line"><span class="javascript">    <span class="comment">// Router 注册监听</span></span></div><div class="line"><span class="javascript">    Router.listen(<span class="function"><span class="keyword">function</span>(<span class="params">location</span>)</span>&#123;</span></div><div class="line"><span class="javascript">        append(location + <span class="string">'-&gt; Router setState.'</span>);</span></div><div class="line"><span class="undefined">    &#125;)</span></div><div class="line"><span class="javascript">    <span class="comment">// historyModule 触发监听回调(对页面进行渲染等处理)</span></span></div><div class="line"><span class="undefined">    historyModule.updateLocation();</span></div><div class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其实上诉的操作就是只是针对前端简单路由+historyModule的升级处理。<br>其中的操作也是类似的。</p>
<ol>
<li>Router.init(historyModule)  ==&gt; Router.protopyte.init</li>
<li>Router.listen(function())   ==&gt; Router.protopyte.route</li>
<li>Router.updateLocation  ==&gt;  Router.protopyte.refresh</li>
</ol>
<h2 id="React-Router代码实现分析"><a href="#React-Router代码实现分析" class="headerlink" title="React-Router代码实现分析"></a>React-Router代码实现分析</h2><p>由于React-Router版本之间的处理方式有些差别，所以就按<a href="https://github.com/ReactTraining/react-router" target="_blank" rel="external">最新版本</a>来进行分析。</p>
<h3 id="historyModule-history-的实现"><a href="#historyModule-history-的实现" class="headerlink" title="historyModule(history)的实现"></a>historyModule(history)的实现</h3><p>//这里针对react-router-dom中的BrowserRouter.js进行分析<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> warning <span class="keyword">from</span> <span class="string">"warning"</span>;</div><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">"react"</span>;</div><div class="line"><span class="keyword">import</span> PropTypes <span class="keyword">from</span> <span class="string">"prop-types"</span>;</div><div class="line"><span class="keyword">import</span> &#123; createBrowserHistory <span class="keyword">as</span> createHistory &#125; <span class="keyword">from</span> <span class="string">"history"</span>;<span class="comment">//这里的history就是上面第二个例子中的historyModule</span></div><div class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">"./Router"</span>; <span class="comment">//对应第二个例子中的Router对象</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The public API for a &lt;Router&gt; that uses HTML5 history. //这里是重点</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BrowserRouter</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  history = createHistory(<span class="keyword">this</span>.props);</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> <span class="attr">children</span>=<span class="string">&#123;this.props.children&#125;</span> /&gt;</span>;</span></div><div class="line"><span class="xml">  &#125;</span></div><div class="line"><span class="xml">&#125;</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">export default BrowserRouter;</span></div></pre></td></tr></table></figure></p>
<p>追踪一下history的实现<br>文件路径在源码中的history中index.ts<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义一个接口</span></div><div class="line"><span class="keyword">export</span> interface History &#123;</div><div class="line">    length: number;</div><div class="line">    action: Action;</div><div class="line">    location: Location;</div><div class="line">    push(path: Path, state?: LocationState): <span class="keyword">void</span>;</div><div class="line">    push(location: LocationDescriptorObject): <span class="keyword">void</span>;</div><div class="line">    replace(path: Path, state?: LocationState): <span class="keyword">void</span>;</div><div class="line">    replace(location: LocationDescriptorObject): <span class="keyword">void</span>;</div><div class="line">    go(n: number): <span class="keyword">void</span>;</div><div class="line">    goBack(): <span class="keyword">void</span>;</div><div class="line">    goForward(): <span class="keyword">void</span>;</div><div class="line">    block(prompt?: boolean): UnregisterCallback;</div><div class="line">    listen(listener: LocationListener): UnregisterCallback;</div><div class="line">    createHref(location: LocationDescriptorObject): Href;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>除去interface这种类型，是不是对History中定义的属性有点熟悉。<a href="http://javascript.ruanyifeng.com/bom/history.html#toc0" target="_blank" rel="external">window.history</a></p>
<h3 id="listen函数的注册"><a href="#listen函数的注册" class="headerlink" title="listen函数的注册"></a>listen函数的注册</h3><p>React-Router/Router.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The public API for putting history on context. //这里的道理类似于例子二中第二步</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Router</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">static</span> childContextTypes = &#123;</div><div class="line">    router: PropTypes.object.isRequired</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  getChildContext() &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      router: &#123;</div><div class="line">        ...this.context.router,</div><div class="line">        history: <span class="keyword">this</span>.props.history,</div><div class="line">        route: &#123;</div><div class="line">          location: <span class="keyword">this</span>.props.history.location,</div><div class="line">          match: <span class="keyword">this</span>.state.match</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  state = &#123;</div><div class="line">    match: <span class="keyword">this</span>.computeMatch(<span class="keyword">this</span>.props.history.location.pathname)</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  computeMatch(pathname) &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      path: <span class="string">"/"</span>,</div><div class="line">      url: <span class="string">"/"</span>,</div><div class="line">      params: &#123;&#125;,</div><div class="line">      isExact: pathname === <span class="string">"/"</span></div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentWillMount() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; children, history &#125; = <span class="keyword">this</span>.props;</div><div class="line">    <span class="comment">// Do this here so we can setState when a &lt;Redirect&gt; changes the</span></div><div class="line">    <span class="comment">// location in componentWillMount. This happens e.g. when doing</span></div><div class="line">    <span class="comment">// server rendering using a &lt;StaticRouter&gt;.</span></div><div class="line">    <span class="keyword">this</span>.unlisten = history.listen(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      <span class="keyword">this</span>.setState(&#123;</div><div class="line">        match: <span class="keyword">this</span>.computeMatch(history.location.pathname)</div><div class="line">      &#125;);</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentWillReceiveProps(nextProps) &#123;</div><div class="line">    warning(</div><div class="line">      <span class="keyword">this</span>.props.history === nextProps.history,</div><div class="line">      <span class="string">"You cannot change &lt;Router history&gt;"</span></div><div class="line">    );</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentWillUnmount() &#123;</div><div class="line">    <span class="keyword">this</span>.unlisten();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; children &#125; = <span class="keyword">this</span>.props;</div><div class="line">    <span class="keyword">return</span> children ? React.Children.only(children) : <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Router;</div></pre></td></tr></table></figure></p>
<p>上面需要有几处需要注意的地方</p>
<ol>
<li>React-Router是利用React的<a href="https://reactjs.org/docs/context.html#how-to-use-context" target="_blank" rel="external">Context</a>进行组件间通信的。childContextTypes/getChildContext </li>
<li>需要特别主要componentWillMount，也就是说在Router组件还未加载之前，listen已经被注册。其实这一步和第一个例子中的init道理是类似的。</li>
<li>在componentWillUnmount中将方法进行注销，用于内存的释放。</li>
<li>这里提到了<redirect> ，其实就是<redirect> 用于url和组件的匹配。</redirect></redirect></li>
</ol>
<h3 id="了解Redirect-js"><a href="#了解Redirect-js" class="headerlink" title="了解Redirect.js"></a>了解Redirect.js</h3><p>react-router/Redirect.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里省去其他库的引用</span></div><div class="line"><span class="keyword">import</span> generatePath <span class="keyword">from</span> <span class="string">"./generatePath"</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The public API for updating the location programmatically</span></div><div class="line"><span class="comment"> * with a component.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Redirect</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line"><span class="comment">//这里是从Context中拿到history等数据</span></div><div class="line">  <span class="keyword">static</span> contextTypes = &#123;</div><div class="line">    router: PropTypes.shape(&#123;</div><div class="line">      history: PropTypes.shape(&#123;</div><div class="line">        push: PropTypes.func.isRequired,</div><div class="line">        replace: PropTypes.func.isRequired</div><div class="line">      &#125;).isRequired,</div><div class="line">      staticContext: PropTypes.object</div><div class="line">    &#125;).isRequired</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  isStatic() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.context.router &amp;&amp; <span class="keyword">this</span>.context.router.staticContext;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentWillMount() &#123;</div><div class="line">    invariant(</div><div class="line">      <span class="keyword">this</span>.context.router,</div><div class="line">      <span class="string">"You should not use &lt;Redirect&gt; outside a &lt;Router&gt;"</span></div><div class="line">    );</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.isStatic()) <span class="keyword">this</span>.perform();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentDidMount() &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.isStatic()) <span class="keyword">this</span>.perform();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  componentDidUpdate(prevProps) &#123;</div><div class="line">    <span class="keyword">const</span> prevTo = createLocation(prevProps.to);</div><div class="line">    <span class="keyword">const</span> nextTo = createLocation(<span class="keyword">this</span>.props.to);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (locationsAreEqual(prevTo, nextTo)) &#123;</div><div class="line">      warning(</div><div class="line">        <span class="literal">false</span>,</div><div class="line">        <span class="string">`You tried to redirect to the same route you're currently on: `</span> +</div><div class="line">          <span class="string">`"<span class="subst">$&#123;nextTo.pathname&#125;</span><span class="subst">$&#123;nextTo.search&#125;</span>"`</span></div><div class="line">      );</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.perform();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  computeTo(&#123; computedMatch, to &#125;) &#123;</div><div class="line">    <span class="keyword">if</span> (computedMatch) &#123;</div><div class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> to === <span class="string">"string"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> generatePath(to, computedMatch.params);</div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">          ...to,</div><div class="line">          pathname: generatePath(to.pathname, computedMatch.params)</div><div class="line">        &#125;;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> to;</div><div class="line">  &#125;</div><div class="line"> <span class="comment">//进行路由的匹配操作</span></div><div class="line">  perform() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; history &#125; = <span class="keyword">this</span>.context.router;</div><div class="line">    <span class="keyword">const</span> &#123; push &#125; = <span class="keyword">this</span>.props;</div><div class="line">    <span class="comment">//Router中拿到需要跳转的路径，然后传递给history</span></div><div class="line">    <span class="keyword">const</span> to = <span class="keyword">this</span>.computeTo(<span class="keyword">this</span>.props);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (push) &#123;</div><div class="line">      history.push(to);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      history.replace(to);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Redirect;</div></pre></td></tr></table></figure></p>
<p>note :</p>
<ol>
<li>针对h5的history来讲，push/replace只是将url进行改变，但是不会触发<a href="https://developer.mozilla.org/en-US/docs/Web/Events/popstate" target="_blank" rel="external">popstate事件</a></li>
</ol>
<h3 id="generatePath函数的处理"><a href="#generatePath函数的处理" class="headerlink" title="generatePath函数的处理"></a>generatePath函数的处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该方法只是对路径进行处理</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Public API for generating a URL pathname from a pattern and parameters.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">const</span> generatePath = <span class="function">(<span class="params">pattern = <span class="string">"/"</span>, params = &#123;&#125;</span>) =&gt;</span> &#123;</div><div class="line">  <span class="keyword">if</span> (pattern === <span class="string">"/"</span>) &#123;</div><div class="line">    <span class="keyword">return</span> pattern;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">const</span> generator = compileGenerator(pattern);</div><div class="line">  <span class="keyword">return</span> generator(params);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="针对路径进行页面渲染处理"><a href="#针对路径进行页面渲染处理" class="headerlink" title="针对路径进行页面渲染处理"></a>针对路径进行页面渲染处理</h3><p>需要看一个Router的结构<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里的Router只是一个容器组件，用于从Redux/react中获取数据，而真正的路径/组件信息存放在Route中</span></div><div class="line"> &lt;Router&gt;</div><div class="line">      &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</div><div class="line">      &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</div><div class="line">      &lt;Route path=<span class="string">"/topics"</span> component=&#123;Topics&#125;/&gt;</div><div class="line">  &lt;<span class="regexp">/Router&gt;</span></div></pre></td></tr></table></figure></p>
<p>看一下Route对组件的处理<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The public API for matching a single path and rendering.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Route</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">    <span class="comment">//从Router中获取信息</span></div><div class="line">  <span class="keyword">static</span> contextTypes = &#123;</div><div class="line">    router: PropTypes.shape(&#123;</div><div class="line">      history: PropTypes.object.isRequired,</div><div class="line">      route: PropTypes.object.isRequired,</div><div class="line">      staticContext: PropTypes.object</div><div class="line">    &#125;)</div><div class="line">  &#125;;</div><div class="line"><span class="comment">//自己定义了一套Contex用于子组件的使用</span></div><div class="line">  <span class="keyword">static</span> childContextTypes = &#123;</div><div class="line">    router: PropTypes.object.isRequired</div><div class="line">  &#125;;</div><div class="line"><span class="comment">//自己定义了一套Contex用于子组件的使用</span></div><div class="line">  getChildContext() &#123;</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">      router: &#123;</div><div class="line">        ...this.context.router,</div><div class="line">        route: &#123;</div><div class="line">          location: <span class="keyword">this</span>.props.location || <span class="keyword">this</span>.context.router.route.location,</div><div class="line">          match: <span class="keyword">this</span>.state.match</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  state = &#123;</div><div class="line">    match: <span class="keyword">this</span>.computeMatch(<span class="keyword">this</span>.props, <span class="keyword">this</span>.context.router)<span class="comment">// matching a URL pathname to a path pattern.如果不匹配，返回null,也就是找不到页面信息</span></div><div class="line">  &#125;;</div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">const</span> &#123; match &#125; = <span class="keyword">this</span>.state;</div><div class="line">    <span class="keyword">const</span> &#123; children, component, render &#125; = <span class="keyword">this</span>.props;<span class="comment">//从Router结构中获取对应的处理方法</span></div><div class="line">    <span class="keyword">const</span> &#123; history, route, staticContext &#125; = <span class="keyword">this</span>.context.router;<span class="comment">//从Context中获取数据</span></div><div class="line">    <span class="keyword">const</span> location = <span class="keyword">this</span>.props.location || route.location;</div><div class="line">    <span class="keyword">const</span> props = &#123; match, location, history, staticContext &#125;;</div><div class="line">    <span class="comment">//如果页面匹配成功，进行createElement的渲染。在这里就会调用component的render===&gt;页面刷新 这是处理第一次页面渲染</span></div><div class="line">    <span class="keyword">if</span> (component) <span class="keyword">return</span> match ? React.createElement(component, props) : <span class="literal">null</span>;</div><div class="line">    <span class="comment">//这里针对首页已经被渲染，在进行路由处理的时候，根据props中的信息，进行页面的跳转或者刷新</span></div><div class="line">    <span class="keyword">if</span> (render) <span class="keyword">return</span> match ? render(props) : <span class="literal">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> Route;</div></pre></td></tr></table></figure></p>
<h1 id="Buzzer"><a href="#Buzzer" class="headerlink" title="Buzzer"></a>Buzzer</h1><p>针对React-Router来讲，其实就是对H5的History进行了一次封装，使能够识别将url的变化与componet渲染进行匹配。</p>
<ol>
<li>根据BrowserRouter等不同的API针对H5的history的重构</li>
<li><router>结构的构建，同时对history属性进行注册。</router></li>
<li>在Router的componentWillMount中注册history的事件回调。</li>
<li>在Redirect中进行路径的计算，调用history.push/history.replace等更新history信息。</li>
<li>Route中根据计算的匹配结果，进行页面首次渲染/页面更新渲染处理。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/04/JS-Variable-Detail/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="踽踽前行的路人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/04/JS-Variable-Detail/" itemprop="url">JS变量和作用域详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-04T19:21:27+08:00">
                2018-01-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>按照ECMAScript-262的定义，JS的变量与其他语言的变量由很大区别。js变量<strong>松散类型</strong>的本质，决定了它只是在<strong>特定时间</strong>用于保存<strong>特定值</strong>的一个<strong>名字</strong>而已。</p>
<h1 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h1><p>ECMAScript变量可能包含两种不同<strong>数据类型</strong>的值：<strong>基本类型值</strong>和<strong>引用类型值</strong>。</p>
<blockquote>
<p>基本类型值：简单的<strong>数据段</strong><br>引用类型值：可能由多个值构成的<strong>对象</strong></p>
</blockquote>
<p>在将一个值赋给<em>变量</em>时，<strong>解析器</strong>必须确定这个值是基本类型还是引用类型。针对于5种基本数据类型：Undefined,Null,Boolean,Number，String.是<strong>按值</strong>访问的，因为可以操作保存在变量中的<strong>实际</strong>的值。<br>引用类型的值是保存在内存中的对象。在js中不允许<strong>直接访问</strong>内存中的位置。也就是说不能直接操作对象的<strong>内存空间</strong>。在操作对象时，实际上是在操作对象的<strong>引用</strong>而不是实际的对象。因此，<strong>引用类型的值是按引用访问的</strong></p>
<p>##动态的属性<br><strong>定义</strong>基本类型值和引用类型值的方式是类似的：<strong>创建一个变量并为该变量赋值</strong>。<br>对于引用类型的值，可以为其<strong>添加</strong>属性和方法，也可以<strong>改变</strong>和<strong>删除</strong>其属性和方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">'lihui'</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//lihui</span></div></pre></td></tr></table></figure></p>
<p>但是对于基本类型来说就有点不同了<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> name = <span class="string">'lihui'</span>;</div><div class="line">name.value = <span class="string">'hehe'</span>;</div><div class="line"><span class="built_in">console</span>.log(name.value);<span class="comment">//undefined</span></div></pre></td></tr></table></figure></p>
<p>上面两个例子就说明，<strong>只能</strong>给<strong>引用类型值</strong>动态的添加属性。</p>
<h2 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h2><p>除了保存方式不同，在从一个变量向另一个变量<strong>复制</strong>基本数据值和引用类型值时，也存在不同。<br>如果从一个变量向另一个变量复制<strong>基本类型</strong>的值，会在<strong>变量对象</strong>上<strong>创建</strong>一个新值，然后把该值<strong>复制</strong>到新变量分配的<strong>位置上</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> num1 = <span class="number">5</span>;</div><div class="line"><span class="keyword">let</span> num2 = num1;</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>复制前的变量对象</th>
<th>复制后变量对象</th>
</tr>
</thead>
<tbody>
<tr>
<td>====<br>num1 = 5</td>
<td>num2 =5<br> num2 = 5</td>
</tr>
</tbody>
</table>
<p>当从一个变量向另一个变量复制<strong>引用类型</strong>的值时，同样也会将存储在变量对象中的值复制一份放到位新变量分配的空间中。不同的是，这个值的<strong>副本</strong>实际上是一个<strong>指针</strong>，而这个指针指向存储在<strong>堆中</strong>的一个对象。复制操作结束后，两个变量实际上将引用<strong>同一个对象</strong>。因此，改变其中一个变量，就会影响另一个变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line"><span class="keyword">let</span> obj2 = obj1;</div><div class="line">obj1.name = <span class="string">'lihui'</span>;</div><div class="line"><span class="built_in">console</span>.log(obj2.name);<span class="comment">//lihui</span></div></pre></td></tr></table></figure></p>
<p>上面的例子中，obj1和obj2都指向<strong>同一个对象</strong>。<br><img src="/image/js/variable/Variable.png" alt=""></p>
<h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>ECMAScript中所有函数的<strong>参数</strong>都是<strong>按值传递</strong>的。也就是说，把函数外部的值<strong>复制</strong>给函数内部的参数，就和把值从一个变量复制到另一个变量一样。<br>在向参数传递基本类型的值时，被传递的值会被复制给一个<strong>局部变量</strong>(即命名参数，或者用ECMAScript的概念来说，就是arguments对象中的一个元素)。在向参数传递<strong>引用类型</strong>的值时，会把这个值的在<strong>内存中的地址</strong>复制给一个局部变量，因此这个局部变量的变化会反映在函数<strong>外部</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    obj.name = <span class="string">"llihui"</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//lihui</span></div></pre></td></tr></table></figure></p>
<p>在这个函数内部，obj和person引用的是同一个对象。换句话说，即使这个变量是<strong>按值传递</strong>的，obj也会<strong>按引用</strong>来访问同一个对象。<br>这里需要有一个地方需要特别注意函数参数中值传递是<strong>按值传递</strong>不是按引用传递。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    obj.name = <span class="string">'lihui'</span>;</div><div class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    obj.name = <span class="string">'78'</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">setName(person);</div><div class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">//lihui</span></div></pre></td></tr></table></figure></p>
<p>如果person是按引用传递的，那么person就会自动被修改为指向其name属性值的’78’的新对象。但是在访问person.name时，显示的值仍热是’lihui’。这就说明即使在函数内部修改了参数的值，但原始的引用任然保持没有变化。<strong>实际上</strong>，当函数内部重写obj时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被<strong>销毁</strong></p>
<hr>
<p>未完待续。。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/03/JS-Operator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="踽踽前行的路人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/03/JS-Operator/" itemprop="url">JS操作符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-03T10:56:56+08:00">
                2018-01-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>ECMAScript-262描述了一组用于<strong>操作数据值</strong>的<strong>操作符</strong>，包括<em>算术</em>操作符、<em>位</em>操作符、<em>关系</em>操作符和<em>相等</em>操作符。ECMAScript的操作符与众不同之处在于，它们能适用很多值，例如String,Number,Boolean,甚至是Object。<br>但是这里需要额外注意的是</p>
<blockquote>
<p>在这些操作符操作Object类型的数据时，相应的operator通常会调用对象的<code>valueOf()</code>和(或)<code>toString()</code>,以便取得可以操作的值。</p>
</blockquote>
<h1 id="一元operator"><a href="#一元operator" class="headerlink" title="一元operator"></a>一元operator</h1><blockquote>
<p>一元操作符：只能操作一个值的操作符。</p>
</blockquote>
<h2 id="递增递减operator"><a href="#递增递减operator" class="headerlink" title="递增递减operator"></a>递增递减operator</h2><p>ECMAScript中的递增和递减操作符直接<strong>借鉴</strong>C。<br>如下简单罗列了递增操作符针对于不同数据类型的转换公式</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>针对String类型的数量来说，都是经过Number(StringVariable)将StringVariable转换为Number类型，但是在针对不同的String数据的时候，就会发生不同的结果 <br>1:StringVariable包含有效数字 ==&gt;Number(StringVariable)+1<br>2:StringVariable不包含有效数字 ==&gt;NaN（由于Number()针对没有有效数字的String变量结果都是NaN，同时NaN参与任何运算的结果也都是NaN）</td>
</tr>
<tr>
<td>Boolean</td>
<td>1:false ==&gt; 0+1<br>2:true ==&gt;1+1</td>
</tr>
<tr>
<td>Object</td>
<td>1：调用对象的valueOf(),提供一个可供<strong>操作</strong>的值，然后根据上诉规则进行判断<br>2:如果1的结果是NaN，就需要调用Object的<code>toString()</code></td>
</tr>
<tr>
<td>Undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>null</td>
<td>Number(null)+1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>通过上诉的总结发现，这里有一个数值转换的内容，其实在递增/递减操作符针对不同<strong>数据类型</strong>操作的时候，在js内部其实都是经过内置的操作函数进行处理的，而这个内置的操作函数就是<code>Number()</code></p>
</blockquote>
<h1 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h1><blockquote>
<p>位操作符用于在最基本的层次上==&gt;按<strong>内存</strong>中表示数值的<em>位</em>来操作数值。</p>
</blockquote>
<p>ECMAScript中的所有数值都以IEEE-754 64位格式存储，但<strong>位操作符</strong>并不直接操作64位的值。而是先将64位的值<strong>转换</strong>为32位的<strong>整数</strong>，最后再将结果转换为64位。</p>
<p>如果对于非数值的数值进行位操作，首先先对该数据进行<code>Number()</code>操作(自动完成)，然后进行对应的位操作，所以无论位操作数对什么数据类型进行操作，返回的<strong>结果</strong>都是<strong>一个数值</strong>。</p>
<h2 id="按位非-NOT"><a href="#按位非-NOT" class="headerlink" title="按位非(NOT)"></a>按位非(NOT)</h2><p>按位非操作符由一个波浪线(~)表示，执行结果是返回<strong>数值的反码</strong>。<br>本质：操作数的<strong>数值</strong>-1</p>
<h2 id="按位与-AND"><a href="#按位与-AND" class="headerlink" title="按位与(AND)"></a>按位与(AND)</h2><p>从本质上将，按位与操作就是将两个<strong>数值</strong>的<strong>每一位</strong>对齐，然后根据一定的规则返回对应的结果。</p>
<table>
<thead>
<tr>
<th>第一个数值的位</th>
<th>第二个数值的位</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>也就是说对于两个操作数中对应的位来说，<strong>相同为1，不同为0</strong></p>
<h2 id="按位或-OR"><a href="#按位或-OR" class="headerlink" title="按位或(OR)"></a>按位或(OR)</h2><table>
<thead>
<tr>
<th>第一个数值的位</th>
<th>第二个数值的位</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p>对于<strong>或</strong>运算来将，就是有<strong>有真则真</strong>。</p>
<h2 id="按位异或-XOR"><a href="#按位异或-XOR" class="headerlink" title="按位异或(XOR)"></a>按位异或(XOR)</h2><table>
<thead>
<tr>
<th>第一个数值的位</th>
<th>第二个数值的位</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>0</td>
<td>0</td>
<td>0</td>
</tr>
</tbody>
</table>
<p> 也就是说的额<strong>相同为0 ，不同为1</strong></p>
<h1 id="布尔操作符"><a href="#布尔操作符" class="headerlink" title="布尔操作符"></a>布尔操作符</h1><p>布尔操作符一共三个：非(NOT)、与(AND)、或(OR).</p>
<h2 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h2><p>可以应用于ECMAScript中的任何值，无论这个值是什么数值类型，该操作符都会返回一个<strong>布尔值</strong>。<br>！操作首先将他的操作数<strong>转换</strong>为一个Boolean值，然后将其<strong>求反</strong>。<br>对于进行<strong>逻辑非</strong>处理的数据需要额外记得的是，对一个数据进行操作，除了下面的<strong>六</strong>种情况，其他的都返回的是<strong>ture</strong>。 </p>
<ul>
<li>‘’(空String) </li>
<li>0(Number)</li>
<li>NaN(Number)</li>
<li>null(Object)</li>
<li>false(Boolean)</li>
<li>undefined(Undefined)</li>
</ul>
<p>其实对数据进行逻辑非处理，在js内核中，进行的是也是<strong>数值转换</strong>。对一个数值进行逻辑非操作，首先利用内置的<strong>转换函数</strong><code>Boolean()</code>对操作数进行转换，然后在转换的结果中进行取反。</p>
<h2 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h2><p>逻辑与操作可以应用于<strong>任何类型</strong>的操作数，而不仅仅是Boolean。在有一个操作数不是布尔值的情况下，逻辑与操作就<strong>不一定返回布尔值</strong>。<br>逻辑与操作属于<strong>短路操作</strong>，即如果第一个操作数能够<strong>决定结果</strong>(如果第一个值进行Boolean()操作之后是false)，那么就不会再对第二个操作数<strong>求值</strong></p>
<h2 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h2><p>与逻辑与操作符相似，逻辑或操作符也是<strong>短路操作符</strong>。</p>
<h1 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h1><p>对于加法操作符(+)来将，根据参与运算的数据类型不同结果不同</p>
<table>
<thead>
<tr>
<th>参与运算的操作符类型</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>都是Number</td>
<td>常c规的加法运行</td>
</tr>
<tr>
<td>都是String</td>
<td>第二个操作数与第一个操作数<strong>拼接</strong></td>
</tr>
<tr>
<td>只有一个操作符为String,则对另外一个操作数转为String</td>
<td><strong>拼接在一起</strong></td>
</tr>
</tbody>
</table>
<p>针对于有一个操作符是String，对于另外一个操作符来将分为两大类</p>
<ul>
<li>操作数为Object/Number/Boolen ==&gt;在进行操作的时候，调用对应数据的<code>toString()</code>取得对应的字符串值。</li>
<li>操作数为null/undefined ==&gt;调用String(),转为对应的String类型。</li>
</ul>
<h1 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h1><p>当关系操作符使用了<strong>非数值</strong>，需要进行数据<strong>转换</strong></p>
<p>| 操作符类型 | 结果 |<br>| 都是数值 | 数值比较 |<br>| 都是字符串 | 字符编码值的比较 |<br>| 一个操作数是数值，则将另外一个操作数转换为数值 | 数值比较 |<br>| 一个操作数是对象，则调用<strong>这个对象</strong>的valueOf()方法，将得到结果运行上述规格进行比较，如果没有valueOf(),就调用对象的toString() | 数值比较 |<br>| 如果操作数是Boolean | 数值比较 |</p>
<blockquote>
<p>从上面的table中可以看到，对于关系操作符的运算，最后会被转换为<strong>数值</strong>的比较，比较无论什么类型的数据在内存中都是以二进制形式存储，采用数值比较速度比较快</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/01/02/React-JSX-In-depth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="踽踽前行的路人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/01/02/React-JSX-In-depth/" itemprop="url">深度解析JSX</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-02T10:47:33+08:00">
                2018-01-02
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>从本质上讲，JSX仅仅是<code>React.createElement(component,props,…children)</code>函数的<strong>语法糖</strong>。<br>如下JSX代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;MyButton color=<span class="string">"blue"</span> shadowSize=&#123;<span class="number">2</span>&#125;&gt;</div><div class="line">  Click Me</div><div class="line">&lt;<span class="regexp">/MyButton&gt;</span></div></pre></td></tr></table></figure></p>
<p>会经过编译器编译为<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">React.createElement(</div><div class="line">    MyButton,</div><div class="line">    &#123;<span class="attr">color</span>:<span class="string">'blue'</span>,<span class="attr">shadowSize</span>:<span class="number">2</span>&#125;,</div><div class="line">    <span class="string">'Click Me'</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<p>如果Element没有<strong>孩子</strong>节点，可以通过自封闭标签来实现<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;div id = <span class="string">'blue'</span>/&gt;</div><div class="line"><span class="comment">//经过编译器编译之后</span></div><div class="line">React.createElement(</div><div class="line">    <span class="string">'div'</span>,</div><div class="line">    &#123;<span class="attr">id</span>:<span class="string">'blue'</span>&#125;,</div><div class="line">    <span class="literal">null</span></div><div class="line">)</div></pre></td></tr></table></figure></p>
<h1 id="指定React元素类型"><a href="#指定React元素类型" class="headerlink" title="指定React元素类型"></a>指定React元素类型</h1><blockquote>
<p>The first part of a JSX tag determines the type of the React element.</p>
</blockquote>
<p>首字母大写的JSX标签代表的是一个React<strong>组件</strong>。这些标签直接被编译为以该<strong>字符</strong>为变量的引用，所以如果你使用JSX<code><foo></foo></code>表达式，Foo必须在<code>&lt;&gt;</code>范围内。</p>
<p>##React Must Be in Scope<br>由于JSX在被编译的时候调用<code>React.createElement</code>,所以<strong>React库</strong>也必须被包含在JSX代码中。<br>例如，下面的<code>imports</code>是必须被包含在你的代码中的，即使<code>React</code>和<code>CustomButton</code>没有被直接引用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> CustomButton <span class="keyword">from</span> <span class="string">'./CustomButton'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">WarningButton</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// return React.createElement(CustomButton, &#123;color: 'red'&#125;, null);</span></div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">CustomButton</span> <span class="attr">color</span>=<span class="string">"red"</span> /&gt;</span>;</span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure></p>
<p>如果你没有使用<strong>JS bundler</strong>从一个<strong>script</strong>标签中引用React库，在被标签中被引用的时候，是引用的全局变量。</p>
<h2 id="使用Dot-Notation-点标记法-来标识JSX类型"><a href="#使用Dot-Notation-点标记法-来标识JSX类型" class="headerlink" title="使用Dot Notation(点标记法)来标识JSX类型"></a>使用Dot Notation(点标记法)来标识JSX类型</h2><p>你可以在JSX中使用<strong>dot-notation</strong>引用一个React组件。如果你有一个<strong>single module</strong>导出很多React组件在引用这些组件的时候，使用<strong>dot-notation</strong>会很方便。例如，如果<code>MyComponents.DatePicker</code>是一个组件，你可以在JSX中直接调用他。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> MyComponents = &#123;</div><div class="line">  DatePicker: <span class="function"><span class="keyword">function</span> <span class="title">DatePicker</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Imagine a &#123;props.color&#125; datepicker here.<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">BlueDatePicker</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">MyComponents.DatePicker</span> <span class="attr">color</span>=<span class="string">"blue"</span> /&gt;</span>;</span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure></p>
<p>##用于自定义的组件必须的大写<br>当一个<code>element</code>类型是以<strong>小写字母</strong>开头，该元素指向的是一个诸如<div>或者是<span>的<strong>内置(built-in)</strong>组件同时在编辑的时候，将一个string ‘div’或者’span’传给<strong>React.createElement</strong>。像<code><foo></foo></code>以首字母大写的Types会被编译成<code>React.createElement(Foo)</code>。</span></div></p>
<blockquote>
<p>在命名自定义组件的时候使用<strong>大写字母</strong>。</p>
</blockquote>
<p>如果存在一个以小写字母命名的组件，在JSX中使用的时候，先将组件赋给一个大写字母开头的变量，然后在使用。<br>例如，下面的代码不会安装预期的效果运行<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"></div><div class="line"><span class="comment">// Wrong! 这是一个组件，应该首字母大写</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="comment">// Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag:</span></div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;props.toWhat&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Wrong! React会认为hello是html tag，因为hello在定义的时候没有以首字母大写</span></div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">hello</span> <span class="attr">toWhat</span>=<span class="string">"World"</span> /&gt;</span>;</span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure></p>
<p>为了修改上述bug，我们将<code>hello</code>重命名为<code>Hello</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="comment">// Correct! This is a component and should be capitalized:</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hello</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="comment">// Correct! This use of &lt;div&gt; is legitimate because div is a valid HTML tag:</span></div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Hello &#123;props.toWhat&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">HelloWorld</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="comment">// Correct! React knows &lt;Hello /&gt; is a component because it's capitalized.</span></div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Hello</span> <span class="attr">toWhat</span>=<span class="string">"World"</span> /&gt;</span>;</span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure></p>
<h2 id="在运行的阶段动态选择Type"><a href="#在运行的阶段动态选择Type" class="headerlink" title="在运行的阶段动态选择Type"></a>在运行的阶段动态选择Type</h2><p>你不能使用一个<strong>表达式</strong>来表示React element的type。如果你想使用表达式来表示元素的类型，首先需要将表达式赋给一个<strong>大写字母开头</strong>的变量。当想根据组件不同的<strong>prop</strong>来渲染组件，这个处理方式是很常见的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; PhotoStory, VideoStory &#125; <span class="keyword">from</span> <span class="string">'./stories'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> components = &#123;</div><div class="line">  photo: PhotoStory,</div><div class="line">  video: VideoStory</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Story</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="comment">// Wrong! JSX type can't be an expression.</span></div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">components[props.storyType]</span> <span class="attr">story</span>=<span class="string">&#123;props.story&#125;</span> /&gt;</span>;</span></div><div class="line"><span class="xml">&#125;</span></div></pre></td></tr></table></figure></p>
<p>修改上述bug，需要将type赋给<strong>大写字母</strong>开头的变量<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</div><div class="line"><span class="keyword">import</span> &#123; PhotoStory, VideoStory &#125; <span class="keyword">from</span> <span class="string">'./stories'</span>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> components = &#123;</div><div class="line">  photo: PhotoStory,</div><div class="line">  video: VideoStory</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Story</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="comment">// Correct! JSX type can be a capitalized variable.</span></div><div class="line">  <span class="keyword">const</span> SpecificStory = components[props.storyType];</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">SpecificStory</span> <span class="attr">story</span>=<span class="string">&#123;props.story&#125;</span> /&gt;</span>;</span></div><div class="line"><span class="xml">&#125;</span></div><div class="line"><span class="xml">//note：在组件被调用的时候，是根据prop的值来渲染不同的组件</span></div><div class="line">&lt;Story storyType="photo"/&gt; //渲染一个照片相关的组件</div></pre></td></tr></table></figure></p>
<h1 id="Props-in-JSX"><a href="#Props-in-JSX" class="headerlink" title="Props in JSX"></a>Props in JSX</h1><h2 id="js表达式作为Props"><a href="#js表达式作为Props" class="headerlink" title="js表达式作为Props"></a>js表达式作为Props</h2><p>你可以通过将<strong>任何</strong>js表达式<strong>包裹</strong>在<code>{}</code>中作为一个JSX中的prop。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;MyComponent foo=&#123;<span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span> + <span class="number">4</span>&#125; /&gt;</div></pre></td></tr></table></figure></p>
<p>从<code>MyComponent</code>角度来说，<code>props.foo</code>的值是10，因为表达式<code>1 + 2 + 3 + 4</code>会被计算。<br><code>if</code>声明和<code>for</code>循环在js中不是表达式，所以他们不能在JSX中直接使用。如果想使用这些声明，你需要将这些声明放置与相关代码中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">NumberDescriber</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> description;</div><div class="line">  <span class="keyword">if</span> (props.number % <span class="number">2</span> == <span class="number">0</span>) &#123;</div><div class="line">    description = <span class="xml"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>even<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    description = <span class="xml"><span class="tag">&lt;<span class="name">i</span>&gt;</span>odd<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;props.number&#125; is an &#123;description&#125; number<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="String变量"><a href="#String变量" class="headerlink" title="String变量"></a>String变量</h2><p>你可以向JSX中传递一个String变量作为<strong>prop</strong>。下面的JSX表达式是等价的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;MyComponent message=<span class="string">"hello world"</span> /&gt;</div><div class="line">&lt;MyComponent message=&#123;<span class="string">'hello world'</span>&#125; /&gt;</div></pre></td></tr></table></figure></p>
<p>当你向JSX中传递string变量的时候，这个变量是<strong>HTML-unescaped(HTML-转义)</strong>的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;MyComponent message=<span class="string">"&amp;lt;3"</span> /&gt;</div><div class="line">&lt;MyComponent message=&#123;<span class="string">'&lt;3'</span>&#125; /&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Prop-默认值为”Ture”"><a href="#Prop-默认值为”Ture”" class="headerlink" title="Prop 默认值为”Ture”"></a>Prop 默认值为”Ture”</h2><p>如果你传递一个没有值的<strong>prop</strong>,这个prop的<strong>默认值</strong>为true.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;MyTextBox autocomplete /&gt;</div><div class="line">&lt;MyTextBox autocomplete=&#123;<span class="literal">true</span>&#125; /&gt;</div></pre></td></tr></table></figure></p>
<h2 id="Spread-Attributes-参数展开"><a href="#Spread-Attributes-参数展开" class="headerlink" title="Spread Attributes(参数展开)"></a>Spread Attributes(参数展开)</h2><p>如果你已经有了一个对象类型的props,同时你想将该变量传递给JSX,你可以使用<code>…</code>将整个props对象通过<strong>扩展</strong>操作传递给JSX中。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">App1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Greeting</span> <span class="attr">firstName</span>=<span class="string">"Ben"</span> <span class="attr">lastName</span>=<span class="string">"Hector"</span> /&gt;</span>;</span></div><div class="line"><span class="xml">&#125;</span></div><div class="line"><span class="xml">function App2() &#123;</span></div><div class="line"><span class="xml">  const props = &#123;firstName: 'Ben', lastName: 'Hector'&#125;;</span></div><div class="line">  return &lt;Greeting &#123;...props&#125; /&gt;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>你也可以挑选一些<strong>特定</strong>的props来供你的组件使用，同时利用<code>…</code>传递<strong>其他</strong>props。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">onst Button = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</div><div class="line">  <span class="keyword">const</span> &#123; kind, ...other &#125; = props;</div><div class="line">  <span class="keyword">const</span> className = kind === <span class="string">"primary"</span> ? <span class="string">"PrimaryButton"</span> : <span class="string">"SecondaryButton"</span>;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&#123;className&#125;</span> &#123;<span class="attr">...other</span>&#125; /&gt;</span>;</span></div><div class="line"><span class="xml">&#125;;</span></div><div class="line"><span class="xml"></span></div><div class="line"><span class="xml">const App = () =&gt; &#123;</span></div><div class="line"><span class="xml">  return (</span></div><div class="line">    &lt;div&gt;</div><div class="line">      &lt;Button kind="primary" onClick=&#123;() =&gt; console.log("clicked!")&#125;&gt;</div><div class="line">        Hello World!</div><div class="line">      &lt;/Button&gt;</div><div class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line"><span class="xml">  );</span></div><div class="line"><span class="xml">&#125;;</span></div></pre></td></tr></table></figure></p>
<p>上面的例子中，<code>kind</code> props是被自定义组件使用而不会被传递到DOM中的<code>button</code>element。如上例子中，向<code>button</code>中传递了<strong>onClick</strong>和<strong>childern props</strong>。</p>
<h1 id="Childern-in-JSX"><a href="#Childern-in-JSX" class="headerlink" title="Childern in JSX"></a>Childern in JSX</h1><p>在JSX表达式中包含一个<strong>opening tag</strong>和<strong>closing tag</strong>,在这两个tag中的内容会被传递给<code>props.children</code>。</p>
<h2 id="String变量-1"><a href="#String变量-1" class="headerlink" title="String变量"></a>String变量</h2><p>你可以在开闭tag中传递一个String，并且props.children的值为<em>这个String</em>。该方式对于一些<strong>内置HTML元素</strong>是有用的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;MyComponent&gt;Hello world!<span class="xml"><span class="tag">&lt;/<span class="name">MyComponent</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<p>这是一个合法的JSX，同时MyComponent中的props.childern的值为”Hello world!”。由于HTML是转义的，所以你可以像写HTML一样写JSX。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;This is valid HTML &amp;amp; JSX at the same time.&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure></p>
<h2 id="JSX-children"><a href="#JSX-children" class="headerlink" title="JSX children"></a>JSX children</h2><p>你可以提供很多JSX elements作为children.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;MyContainer&gt;</div><div class="line">  &lt;MyFirstComponent /&gt;</div><div class="line">  &lt;MySecondComponent /&gt;</div><div class="line">&lt;<span class="regexp">/MyContainer&gt;</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>A React component can also return an array of elements:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">render() &#123;</div><div class="line">  <span class="comment">// No need to wrap list items in an extra element!</span></div><div class="line">  <span class="keyword">return</span> [</div><div class="line">    <span class="comment">// Don't forget the keys :)</span></div><div class="line">    &lt;li key=<span class="string">"A"</span>&gt;First item&lt;<span class="regexp">/li&gt;,</span></div><div class="line"><span class="regexp">    &lt;li key="B"&gt;Second item&lt;/</span>li&gt;,</div><div class="line">    &lt;li key=<span class="string">"C"</span>&gt;Third item&lt;<span class="regexp">/li&gt;,</span></div><div class="line"><span class="regexp">  ];</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>note :这是React1.6版本所新增的，在1.6之前的版本是不支持返回数组的。</p>
<h2 id="js表达式作为children"><a href="#js表达式作为children" class="headerlink" title="js表达式作为children"></a>js表达式作为children</h2><p>你可以通过将js表达式内嵌在<code>{}</code>中作为JSX的children.<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;MyComponent&gt;foo&lt;<span class="regexp">/MyComponent&gt;</span></div><div class="line"><span class="regexp">&lt;MyComponent&gt;&#123;'foo'&#125;&lt;/</span>MyComponent&gt;</div></pre></td></tr></table></figure></p>
<p><strong>这种处理方式对于渲染一个拥有可变长度的list。</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Item</span>(<span class="params">props</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;props.message&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">TodoList</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">const</span> todos = [<span class="string">'finish doc'</span>, <span class="string">'submit pr'</span>, <span class="string">'nag dan to review'</span>];</div><div class="line">  <span class="keyword">return</span> (</div><div class="line">    &lt;ul&gt;</div><div class="line">      &#123;todos.map(<span class="function">(<span class="params">message</span>) =&gt;</span> &lt;Item key=&#123;message&#125; message=&#123;message&#125; /&gt;)&#125;</div><div class="line">    &lt;<span class="regexp">/ul&gt;</span></div><div class="line"><span class="regexp">  );</span></div><div class="line"><span class="regexp">&#125;</span></div></pre></td></tr></table></figure></p>
<h2 id="Booleans-Null-and-Undefined-会被忽略"><a href="#Booleans-Null-and-Undefined-会被忽略" class="headerlink" title="Booleans, Null, and Undefined 会被忽略"></a>Booleans, Null, and Undefined 会被忽略</h2><p>false, null, undefined和 true 都是合法的children. 他们不会被编译渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;div /&gt;</div><div class="line">&lt;div&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div><div class="line">&lt;div&gt;&#123;<span class="literal">false</span>&#125;&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">&lt;div&gt;&#123;null&#125;&lt;/</span>div&gt;</div><div class="line">&lt;div&gt;&#123;<span class="literal">undefined</span>&#125;&lt;<span class="regexp">/div&gt;</span></div><div class="line"><span class="regexp">&lt;div&gt;&#123;true&#125;&lt;/</span>div&gt;</div></pre></td></tr></table></figure></p>
<p>上述情况对于<strong>有条件</strong>的渲染element是十分有用的。该JSX仅仅<code>showHeader</code>为<code>true</code>的时候才会被渲染。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">  &#123;showHeader &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Header</span> /&gt;</span>&#125;</span></div><div class="line"><span class="xml">  <span class="tag">&lt;<span class="name">Content</span> /&gt;</span></span></div><div class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>这里需要特别注意的是：针对对Number类型的0，按照上述逻辑，在处理的时候，是不会被渲染的，但是在React内核中，是会选择渲染的。</p>
</blockquote>
<p>如果你想让诸如false，true，null，undefined被渲染，你需要将这些值转换为String类型。<strong>String(param)</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div&gt;</div><div class="line">&#123;<span class="built_in">String</span>(<span class="literal">false</span>)&#125;</div><div class="line">&lt;<span class="regexp">/div&gt;</span></div></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/29/JS-Common-Simple-Function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="踽踽前行的路人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/29/JS-Common-Simple-Function/" itemprop="url">JS-简易函数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-29T18:06:22+08:00">
                2017-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>#解析URL字符串，返回包含所有参数的对象</p>
<h2 id="利用for循环"><a href="#利用for循环" class="headerlink" title="利用for循环"></a>利用for循环</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="comment">//取得查询字符串并去掉开头的问号</span></div><div class="line">    <span class="keyword">let</span> qs = (location.search.length&gt;<span class="number">0</span>?location.search.substring(<span class="number">1</span>):<span class="string">""</span>);</div><div class="line">    <span class="comment">//保存数据的对象</span></div><div class="line">    <span class="keyword">let</span> args =&#123;&#125;;</div><div class="line">    <span class="comment">//取得每一项</span></div><div class="line">    <span class="keyword">let</span> items =qs.length?qs.split(<span class="string">"&amp;"</span>):[];</div><div class="line">    <span class="keyword">let</span> item =<span class="literal">null</span>,name=<span class="literal">null</span>,value=<span class="literal">null</span>;</div><div class="line">    <span class="comment">//在for循环中使用</span></div><div class="line">    <span class="keyword">let</span> i=<span class="number">0</span>,len = items.length;</div><div class="line">    <span class="comment">//逐个将每一项添加到args对象中</span></div><div class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;len;i++)&#123;</div><div class="line">        item = items[i].split(<span class="string">"="</span>);</div><div class="line">        name = <span class="built_in">decodeURIComponent</span>(item[<span class="number">0</span>]);</div><div class="line">        value = <span class="built_in">decodeURIComponent</span>(item[<span class="number">1</span>]);</div><div class="line">        <span class="keyword">if</span>(name.length)&#123;</div><div class="line">            args[name] = value;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"><span class="keyword">return</span> args;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="利用Regexp"><a href="#利用Regexp" class="headerlink" title="利用Regexp"></a>利用Regexp</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getQueryStringArgs</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">     <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="comment">//获取url的参数部分</span></div><div class="line">    <span class="keyword">var</span> params = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>);</div><div class="line">    <span class="comment">//[^&amp;=]+ 表示不含&amp;或=的连续字符，加上()就是提取对应字符串</span></div><div class="line">    params.replace(<span class="regexp">/([^&amp;=]+)=([^&amp;=]*)/gi</span>,<span class="function"><span class="keyword">function</span>(<span class="params">rs,$<span class="number">1</span>,$<span class="number">2</span></span>)</span>&#123;</div><div class="line">        obj[$<span class="number">1</span>] =  <span class="built_in">decodeURIComponent</span>($<span class="number">2</span>);</div><div class="line">    &#125;);</div><div class="line">  </div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Buzzer"><a href="#Buzzer" class="headerlink" title="Buzzer"></a>Buzzer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//示例URL:</span></div><div class="line">http:<span class="comment">//platform.hncpre.jcloudec.com/terminal-service-operating-view/terminalprovider?name="sdfsdf"&amp;age=1&amp;address=%27asdfsdf%27</span></div><div class="line"><span class="comment">//在页面中调用方法，用一个变量来接受</span></div><div class="line"><span class="keyword">let</span> result = getQueryStringArgs();</div><div class="line"><span class="built_in">console</span>.log(result[<span class="string">"name"</span>])  <span class="comment">//sdfsdf</span></div></pre></td></tr></table></figure>
<h1 id="对象数组，根据对象的某个属性进行排序"><a href="#对象数组，根据对象的某个属性进行排序" class="headerlink" title="对象数组，根据对象的某个属性进行排序"></a>对象数组，根据对象的某个属性进行排序</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/定义一个比较函数</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1,object2</span>)</span>&#123;</div><div class="line">        <span class="keyword">let</span> value1 = object1[propertyName];</div><div class="line">        <span class="keyword">let</span> value2 = object2[propertyName];</div><div class="line">        <span class="keyword">if</span>(value1&lt;value2)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1&gt;value2)&#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">        &#125;<span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//例如：存在如下数组</span></div><div class="line"><span class="keyword">let</span> data  = [&#123;<span class="attr">name</span>:<span class="string">"Zhang"</span>,<span class="attr">age</span>:<span class="number">1</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">"Li"</span>,<span class="attr">age</span>:<span class="number">2</span>&#125;];</div><div class="line"><span class="comment">//利用sort函数进行处理</span></div><div class="line">data.sort(createComparisonFunction(<span class="string">"name"</span>))</div></pre></td></tr></table></figure>
<p>上面的函数只是简单的模仿sort的处理方式，只是一个模板，如果遇到其他的需求，需要对value1,value2进行<br>特殊的处理  </p>
<blockquote>
<p>sort内部采用的是快排算法</p>
</blockquote>
<h1 id="对象数组去重"><a href="#对象数组去重" class="headerlink" title="对象数组去重"></a>对象数组去重</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//定义了一个函数用于存放最后的结果</span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * emptyArr：用于存放最后的结果，</span></div><div class="line"><span class="comment">    sourceItem：数组中的每一项</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">duplicate</span>(<span class="params">emptyArr,sourceItem</span>)</span>&#123;</div><div class="line">    <span class="keyword">let</span> result = emptyArr.some(</div><div class="line">        item=&gt;<span class="built_in">JSON</span>.stringify(item)==<span class="built_in">JSON</span>.stringify(sourceItem)</div><div class="line">    )</div><div class="line">    <span class="keyword">if</span>(!result)&#123;</div><div class="line">        emptyArr.push(sourceItem)</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> emptyArr=[];</div><div class="line">arr.forEach(<span class="function"><span class="params">item</span>=&gt;</span>duplicate(emptyArr,item))</div></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/29/React-Component-Isolation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="踽踽前行的路人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/29/React-Component-Isolation/" itemprop="url">React组件隔离</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-29T16:48:36+08:00">
                2017-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>组件隔离适用范围<br>  同一个页面引用多个相同的<strong>自定义公共组件</strong>(该类组件拥有自己的Redux)并且这些组件之间有交互。<br>案例背景<br>   在一个页面中存在两个相同的公共组件(A)，在页面处理中，对A组件进行操作，有一些重要的数据被存入到A组件的对应的Redux中。<br>如果该页面只存在一个A组件，不管进行如何的操作，数据都是一份。但是如果该页面中存在多个A组件，在对第一个A组件进行数据处理之后，数据存入到Rudex中。此时在对另一个A组件进行相同的操作步骤，但是存入的数据和第一个A组件的存储在Redux中的数据有差别，此时在第二个A组件的操作就会影响第一个A组件的数据。</p>
<blockquote>
<p> 原因：由于页面中引用的是相同的组件，在进行数据处理的时候，都会存在到Redux中，而该组件的Redux在内存中只是保存了一份。</p>
</blockquote>
<p>这就类似于如下操作<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> ob1 = <span class="keyword">new</span> <span class="built_in">Object</span>();======类似===&gt;定义了一个组件</div><div class="line">ob1.name = <span class="string">'haha'</span>;=========类似====&gt;进行数据处理的时候，将组件的一些数据存入到对应的Redux中。</div><div class="line">==============华丽的分割线==================</div><div class="line">ob1.name =<span class="string">"hehe"</span>;=========类似=====&gt;此处类似于第二个组件进行相同的操作，将对应的Redux中的数据进行了变化，该变化会影响到上面的代码。</div></pre></td></tr></table></figure></p>
<h1 id="利用Provider"><a href="#利用Provider" class="headerlink" title="利用Provider"></a>利用Provider</h1><p>在需要处理组件隔离的页面中引用如下代码<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123; Provider &#125; <span class="keyword">from</span> <span class="string">'react-redux'</span>;[Provider属于react-redux](https:<span class="comment">//github.com/reactjs/react-redux/blob/master/docs/api.md#provider-store)</span></div><div class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">'redux'</span>   ===&gt;用于生成总的Store</div><div class="line"><span class="keyword">import</span> &#123; Router, browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span>;</div></pre></td></tr></table></figure></p>
<p>在组件的constructor中进行变量的初始化<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonComponent</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props,context)&#123;</div><div class="line">    <span class="keyword">super</span>(props,context);</div><div class="line">    <span class="keyword">this</span>.store1 = createStore(reducer);  ===&gt;此处的reducer是你自己的页面的reducer</div><div class="line">  &#125;</div><div class="line">  render()&#123;</div><div class="line">      <span class="comment">//....</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于<a href="https://github.com/reactjs/redux/blob/master/docs/api/createStore.md" target="_blank" rel="external">createStore</a><br>处理需要隔离的组件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">render()&#123;</div><div class="line">    &lt;div&gt;</div><div class="line">        &lt;A/&gt;</div><div class="line">        &lt;Provider store=&#123;<span class="keyword">this</span>.store1&#125;&gt;  ===&gt;此处的store1是根据你页面的reducer构建的</div><div class="line">             &lt;A/&gt;  ==&gt;此处为需要隔离的组件</div><div class="line">        &lt;<span class="regexp">/Provider&gt;</span></div><div class="line"><span class="regexp">    &lt;/</span>div&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>基于如上操作，第二个A组件被成功的隔离出<strong>整个Store树之外</strong>(换句话说，该A组件自己定义了一套Store)</p>
<p>但是，组件隔离是为了在操作之后，拥有相同的Redux的组件在进行相同的操作步骤之后，互相不被影响。所以，需要根据刚才在第二步构建的<strong>Store1来进行对应的action的dispatch.</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">this</span>.store1.getState().xxx   ===&gt;此处的xxx是在rootReducer.js中combineReducers引用的A组件的Redux的同名State(Note：此处也有对应的方法起一个与Redux不同的名字，自行百度吧)</div><div class="line">上面是用于获取A组件中state数据的，</div><div class="line"><span class="keyword">this</span>.store1.dispatch(yyy（param）)  ===&gt;此处的yyy是在A组件的ActionCreator   (该用法请参考Redux官网)</div></pre></td></tr></table></figure></p>
<p>上面一行代码用户发送一个action</p>
<h1 id="利用第三方库multireducer"><a href="#利用第三方库multireducer" class="headerlink" title="利用第三方库multireducer"></a>利用第三方库multireducer</h1><blockquote>
<p>multireducer该库的主要目的就是为了实现组件隔离。</p>
</blockquote>
<p><a href="https://github.com/erikras/multireducer" target="_blank" rel="external">对应的github地址</a><br>核心思想：A utility to wrap many copies of a single Redux reducer into a single key-based reducer.</p>
<h2 id="项目中引用multireducer"><a href="#项目中引用multireducer" class="headerlink" title="项目中引用multireducer"></a>项目中引用multireducer</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save multireducer</div></pre></td></tr></table></figure>
<h2 id="在组件定义处处理"><a href="#在组件定义处处理" class="headerlink" title="在组件定义处处理"></a>在组件定义处处理</h2><h3 id="引用connectMultireducer"><a href="#引用connectMultireducer" class="headerlink" title="引用connectMultireducer"></a>引用connectMultireducer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> &#123;connectMultireducer&#125; <span class="keyword">from</span> <span class="string">'multireducer'</span>;</div></pre></td></tr></table></figure>
<h3 id="组件与Redux进行关联"><a href="#组件与Redux进行关联" class="headerlink" title="组件与Redux进行关联"></a>组件与Redux进行关联</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">@connectMultireducer(</div><div class="line">  (key, state) =&gt; (&#123;<span class="attr">count</span>: state.multireducer[key].count&#125;),</div><div class="line">  &#123;increment&#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<p>此处的处理方式和华南城项目中@connect的用法类似<br>主要的区别在与该方法中第二个参数为需要隔离组件的redux.js</p>
<h3 id="在组件调用除处理"><a href="#在组件调用除处理" class="headerlink" title="在组件调用除处理"></a>在组件调用除处理</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;A multireducerKey=<span class="string">"1"</span> /&gt;</div><div class="line"> &lt;A multireducerKey=<span class="string">"2"</span> /&gt;</div><div class="line"> &lt;A multireducerKey=<span class="string">"3"</span> /&gt;</div></pre></td></tr></table></figure>
<p>此处在一个页面中引用了三个相同的组件，有一个multireducerKey是必须的，用于区分组件。(这和React在处理List等拥有相同数据结构的组件的时候，需要一个key是相同的道理)</p>
<h3 id="处理Rudecer"><a href="#处理Rudecer" class="headerlink" title="处理Rudecer"></a>处理Rudecer</h3><p>在进行combineReducers处，需要指出刚才multireducerKey对应的value是指的什么<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> combineReducers(&#123;</div><div class="line">  routing: routerReducer,</div><div class="line">  reduxAsyncConnect,</div><div class="line">  multireducer: multireducer(&#123;</div><div class="line">    <span class="number">1</span>: XXX,</div><div class="line">    <span class="number">2</span>: XXX,</div><div class="line">    <span class="number">3</span>: XXX</div><div class="line">  &#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>此处的格式是固定的，XXX代表需要进行隔离处理的组件的Redux，对应的1,2,3就是在步骤3处multireducerKey的值，(note：说的是格式固定，但是其中的参数是可以根据自己的情况进行变化的)</p>
<p>基于如上的4步操作就可以将A组件进行组件隔离操作了。<br>原理解释</p>
<p><strong>采用此处的处理方式与第一种处理方式相比，被隔离的组件没有脱离整个Store树，而是根据multireducerKey来判断用户当前操作发送的action是来自哪个一个，然后根据multireducerKey进行对应的数据操作处理。</strong></p>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/27/JS-Variable-DataType/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="踽踽前行的路人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/27/JS-Variable-DataType/" itemprop="url">JS-变量-数据类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-27T22:17:45+08:00">
                2017-12-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/js/" itemprop="url" rel="index">
                    <span itemprop="name">js</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><p>ECMAScript的变量是<strong>松散</strong>类型的，所谓松散类型就是可以保存<strong>任何类型</strong>的数据。换句话说，每个变量仅仅是一个用于保存值的<strong>占位符</strong>。<br>定义变量的时候用var(ES5)   let/const(ES6)等操作符。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> paramA;</div><div class="line"><span class="keyword">let</span> paramB;</div><div class="line"><span class="keyword">const</span> paramC;</div></pre></td></tr></table></figure></p>
<p>上面的代码定义变量paramX，变量可以用来保存<strong>任何值</strong>(如上定义的变量，是未经初始化的变量，会保存一个特殊的值—undefined)</p>
<h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>ECMAScript中有5种<strong>简单数据类型</strong>(基本数据类型)</p>
<ul>
<li>数值（Number）：整数和小数（比如1和3.14）</li>
<li>字符串（String）：字符组成的文本（比如”Hello World”）</li>
<li>布尔值（Boolean）：true（真）和false（假）两个特定值</li>
<li>Undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</li>
<li>Null：表示无值，即此处的值就是“无”的状态。</li>
</ul>
<p>还有1中复杂数据类型</p>
<ul>
<li>对象(Object): 本质上是由一组无序的<strong>名值</strong>对组成。其实对象也可以细分</li>
</ul>
<ol>
<li>狭义的对象（object）</li>
<li>数组（array）</li>
<li>函数（function）</li>
</ol>
<p>针对于ES5来说只有上诉的6中数据类型，而对于ES6来说又新增了<a href="http://es6.ruanyifeng.com/#docs/symbol" target="_blank" rel="external">Symbol</a></p>
<h2 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h2><p>鉴于ECMAScript的数据类型是松散的，所以需要一种手段来检测给定变量的数据类型<strong>typeof</strong>。</p>
<h3 id="原始数据类型"><a href="#原始数据类型" class="headerlink" title="原始数据类型"></a>原始数据类型</h3><p>数值、字符串、布尔值分别返回number、string、boolean<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="number">123</span> <span class="comment">// "number"</span></div><div class="line"><span class="keyword">typeof</span> <span class="string">'123'</span> <span class="comment">// "string"</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">false</span> <span class="comment">// "boolean"</span></div></pre></td></tr></table></figure></p>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数返回function<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</div><div class="line"><span class="keyword">typeof</span> f</div><div class="line"><span class="comment">// "function"</span></div></pre></td></tr></table></figure></p>
<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>undefined返回undefined。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span></div><div class="line"><span class="comment">// "undefined"</span></div></pre></td></tr></table></figure></p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>除此以外，其他情况都返回object。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="built_in">window</span> <span class="comment">// "object"</span></div><div class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// "object"</span></div><div class="line"><span class="keyword">typeof</span> [] <span class="comment">// "object"</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// "object"</span></div></pre></td></tr></table></figure></p>
<h3 id="Buzzer"><a href="#Buzzer" class="headerlink" title="Buzzer"></a>Buzzer</h3><p>这里需要特别注意的一点：对于ES5对于没有定义的变量typeof undefinedParam //undefined,但是对于用ES6中let/const定义的变量，在变量定义之前进行typeof操作的话，会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> paramVar;<span class="comment">//undefined</span></div><div class="line"><span class="keyword">var</span> paramVar;</div><div class="line"><span class="keyword">typeof</span> paramLet;<span class="comment">//ReferenceError:paramLet is not defined</span></div><div class="line"><span class="keyword">let</span> paramLet</div></pre></td></tr></table></figure></p>
<p>出现上述问题的根源在于两点</p>
<ol>
<li>用var定义的变量会发现<strong>变量提升</strong></li>
<li>用let/const定义的变量存在TDZ(暂时性死区)</li>
</ol>
<h2 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h2><p>Undefined类型<em>只有</em>一个值，既特殊的undefined。在使用var/let/const等操作符声明变量但是没有赋初值时，这个变量的值就是undefined。</p>
<blockquote>
<p>undefined的主要目的是用于比较，而在ECMA-262第三版之前是不存在的。在第三版引入这个值是为了正式区分<strong>空对象指针</strong>(null)与未经初始化的变量。</p>
</blockquote>
<h2 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h2><p>Null类型是第二个<strong>只有一个值</strong>的数据类型，这个特殊的值是null。从逻辑角度来看，null值表示一个<strong>空对象指针</strong>，而这也是使用typeof检测null值的时会返回”object”的原因。</p>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><p>Boolean类型只有两个字面量：true和false。<br>虽然Boolean类型的字面量只有两个，但是ECMAScript中所有类型的值都有与这两个Boolean值<strong>等价</strong>的值。要将一个值转换为其对应的Boolean值，可以调用<em>转型</em>函数–Boolean();</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>任何非空字符串</td>
<td>“”(空字符串)</td>
</tr>
<tr>
<td>Number</td>
<td>任何非0数字值(+∞)</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>不适用</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<h2 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h2><p>ECMAScript中使用<a href="http://blog.csdn.net/k346k346/article/details/50487127" target="_blank" rel="external">IEEE754</a>标准中<strong>双精度浮点数</strong>来表示一个数字，<strong>不区分整数和浮点数</strong>。</p>
<blockquote>
<p>IEEE754:<br>在 IEEE754 中，双精度浮点数采用 64 位存储，即 8 个字节表示一个浮点数 。其存储结构如下图所示：<br><img src="/image/js/dataType/iee754.png" alt=""></p>
<ul>
<li>第1位：符号位，0表示正数，1表示负数</li>
<li>第2位到第12位：指数部分</li>
<li>第13位到第64位：小数部分（即有效数字）</li>
</ul>
</blockquote>
<p>指数位可以通过下面的方法转换为使用的指数值：<br><img src="/image/js/dataType/indexTranform.png" alt=""></p>
<p>note :<strong>由于保存浮点数值需要的内存是整数值的两倍，因此ECMAScript会</strong>不失时机<strong>的将浮点数值转换为整数值。</strong>其实Number类型采用的是<strong>双精度浮点数</strong>，但是在保存和应用的时候，为了内存和速度考虑，会表现出整数和浮点数的区分。</p>
<h3 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h3><blockquote>
<p>浮点数值：数值中<strong>必须</strong>包含一个小数点，并且小数点后面必须至少有一位数值。</p>
</blockquote>
<p>浮点数值的最高精度是17位小数，但在进行算术计算时其精度远远不如整数。这样就会导致一些违背常理的bug。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="number">0.1</span>,b = <span class="number">0.2</span>;</div><div class="line">a+b ==<span class="number">0.3</span>;<span class="comment">//false</span></div></pre></td></tr></table></figure></p>
<p>出现这种<strong>精度缺失</strong>的情况，在于IEEE754内存结构导致的。<br><a href="http://www.cnblogs.com/onepixel/p/5140944.html" target="_blank" rel="external">出现上诉问题的深度解析</a></p>
<h3 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h3><p>从存储结构中可以看出， 指数部分的长度是11个二进制，即指数部分能表示的最大值是 2047（211-1），取中间值进行偏移，用来表示负指数，也就是说指数的范围是 [-1023,1024] 。因此，这种存储结构能够表示的数值范围为 2的1024次方 到 2的-1023次方 ，超出这个范围的数无法表示 。2的1024次方  转换为科学计数法如下所示：<br>2的1024次方  = 1.7976931348623157 × 10308</p>
<p>因此，JavaScript 中能表示的最大值是 1.7976931348623157e+308，最小值为 5e-324 。</p>
<p>这两个边界值可以分别通过访问 Number 对象的 MAX_VALUE 属性和 MIN_VALUE 属性来获取：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.MAX_VALUE; <span class="comment">//1.7976931348623157e+308</span></div><div class="line"><span class="built_in">Number</span>.MIN_VALUE; <span class="comment">//5e-324</span></div></pre></td></tr></table></figure></p>
<p>如果数字超过最大值或最小值，JavaScript 将返回一个不正确的值，这称为正向溢出(overflow) 或 负向溢出(underflow) 。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>.MAX_VALUE+<span class="number">1</span> == <span class="built_in">Number</span>.MAX_VALUE; <span class="comment">//true</span></div><div class="line"><span class="built_in">Number</span>.MAX_VALUE+<span class="number">1e292</span>; <span class="comment">//Infinity</span></div><div class="line"><span class="built_in">Number</span>.MIN_VALUE + <span class="number">1</span>; <span class="comment">//1</span></div><div class="line"><span class="built_in">Number</span>.MIN_VALUE - <span class="number">3e-324</span>; <span class="comment">//0</span></div><div class="line"><span class="built_in">Number</span>.MIN_VALUE - <span class="number">2e-324</span>; <span class="comment">//5e-324</span></div></pre></td></tr></table></figure></p>
<h3 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h3><p>在 64 位的二进制中，<em>符号位</em>决定了一个数的<strong>正负</strong>，<em>指数</em>部分决定了<strong>数值的大小</strong>，<em>小数</em>部分决定了<strong>数值的精度</strong>。<br>IEEE754 规定，<em>有效数字</em>第一位<strong>默认总是1</strong> 。因此，在表示精度的尾数前面，还存在一个<strong>隐藏位</strong> ，固定为 1 ，但它<em>不保存</em>在 64 位浮点数之中。也就是说，有效数字总是 1.xx…xx 的形式，其中 xx..xx 的部分保存在 64 位浮点数之中，最长为52位 。所以，<strong>JavaScript 提供的有效数字最长为 53 个二进制位</strong>，其内部实际的表现形式为：</p>
<p>(-1)^符号位 <em> 1.xx…xx </em> 2^指数位<br>这意味着，JavaScript 能表示并进行精确算术运算的整数范围为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//最大</span></div><div class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)<span class="number">-1</span> ; <span class="comment">// 9007199254740991</span></div><div class="line"><span class="comment">//最少</span></div><div class="line">-<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>)<span class="number">-1</span> ; <span class="comment">// -9007199254740991</span></div></pre></td></tr></table></figure></p>
<p>可以通过 Number.MAX_SAFE_INTEGER 和  Number.MIN_SAFE_INTEGER 来分别获取这个最大值和最小值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) ; <span class="comment">// 9007199254740991</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Number</span>.MIN_SAFE_INTEGER) ; <span class="comment">// -9007199254740991</span></div></pre></td></tr></table></figure></p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><blockquote>
<p>NaN：即非数值(Not a Number)是一个特殊的<strong>数值</strong>，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况。</p>
</blockquote>
<p>NaN本身有两个不同寻常的特点</p>
<ol>
<li>任何涉及NaN的操作(NaN/10)都会返回NaN</li>
<li>NaN与任何值都不相等，<strong>包括NaN本身</strong></li>
</ol>
<p>针对NaN的这个两个特点，ECMAScript定义了isNaN()函数。该函数接受一个参数，参数可以是<strong>任何类型</strong>。</p>
<h3 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h3><p>有三个函数可以把非数值转换为数值：</p>
<ul>
<li>Number() :可以用于<strong>任何</strong>数据类型</li>
<li>parseInt() : <em>专门</em>用于把字符串转成数值</li>
<li>parseFloat() : <em>专门</em>用于把字符串转成数值</li>
</ul>
<p>Number()针对不同类型的数据类型转换如下</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true=&gt;1 false=&gt;0</td>
</tr>
<tr>
<td>Number</td>
<td>简单的传入传出</td>
</tr>
<tr>
<td>null</td>
<td>0</td>
</tr>
<tr>
<td>undefined</td>
<td>NaN</td>
</tr>
<tr>
<td>String</td>
<td>1:如果只包含数字(包括前面带-/+的情况),=&gt;<strong>十进制</strong>数值<br> 2：包含有效的<strong>浮点格式</strong>(eg:1.1),=&gt;对应的<strong>浮点</strong>数值<br> 3：含有有效的<strong>十六进制</strong>格式(eg:0xf),=&gt;相同大小的<strong>十进制</strong>数值<br> 4：空串 =&gt;0 <br>5：除了前几个情况，=&gt;NaN</td>
</tr>
<tr>
<td>Object</td>
<td>1：调用对象的valueOf()方法，按照前面的规格进行转换返回的值<br>2：如果结果1的值是NaN,则调用对象的toString()方法，再次根据上诉规则转换返回的值</td>
</tr>
</tbody>
</table>
<blockquote>
<p>一元加操作符的操作与Number()函数作用一样。<br>使用Number对String进行转换的时候，会发生违背常规的情况。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Number</span>(<span class="string">''</span>)<span class="comment">//0</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>所以在转换String类型为Number类型的时候，一般是用parseInt()。<em>parseInt()函数在转换String时，更多的是看String是否符合<strong>数值模式</strong>。它会忽略字符串前面的空格，直到找到第一个<strong>非空格字符</strong>。如果<strong>第一个</strong>字符不是<strong>数字</strong>字符或者<em>*负号</em></em>，parseInt()就会返回NaN。<br>这样就规避了利用Number()对’’进行转换的情况<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">parseInt</span>(<span class="string">''</span>)<span class="comment">//NaN</span></div></pre></td></tr></table></figure></p>
<p>如果想将String转换为浮点数类型，可以使用parseFloat()。</p>
<h2 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h2><p>String类型是用于表示由零或者多个<strong>16位<a href="https://www.zhihu.com/question/23374078" target="_blank" rel="external">Unicode字符</a></strong>组成的字符序列。</p>
<h3 id="String的特点"><a href="#String的特点" class="headerlink" title="String的特点"></a>String的特点</h3><p>ECMAScript中的String是不可变的，也就是说，String一旦<strong>创建</strong>，他们的值就不能改变。要改变某个变量保存的String,首先要销毁原来的String，然后再用另一个包含新值的String<strong>填充</strong>该变量。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> stringVariable = <span class="string">'hehe'</span>;</div><div class="line">stringVariable = stringVariable + <span class="string">'haha'</span>;</div></pre></td></tr></table></figure></p>
<p>实现这个操作的过程如下：</p>
<ol>
<li>创建一个能容纳8个字符的<strong>新</strong>String</li>
<li>在这个String中<strong>填充</strong> “hehe”和”haha”</li>
<li><strong>销毁</strong>原来的String “hehe”和”haha”</li>
</ol>
<h3 id="转换为String"><a href="#转换为String" class="headerlink" title="转换为String"></a>转换为String</h3><p>要把一个值转换为String有两种方式</p>
<ol>
<li>toString() 返回相应值的字符串表现<br>note:null和undefined值没有这个方法</li>
<li>String() 能够将<strong>任何</strong>类型的值转换为String.<br>String()函数遵循下列转换规则</li>
</ol>
<ul>
<li>如果值有toString()方法，则调用该方法(没有参数)并返回相应的结果</li>
<li>null =&gt;”null”</li>
<li>undefined =&gt; “undefined”</li>
</ul>
<h2 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h2><blockquote>
<p>一组<strong>数据</strong>和<strong>功能</strong>的集合。</p>
</blockquote>
<p>对象可以通过执行new 操作符后跟要创建的<strong>对象类型</strong>的<em>名称</em>来创建。而创建Object类型的<strong>实例</strong>并为其添加<em>属性</em>和(或)<em>方法</em>，就可以创建<strong>自定义</strong>对象。<br><strong>在ECMAScript中，Object类型是所有它的实例的基础</strong>换句话说，Object类型所具有的<strong>任何属性和方法</strong>也同样存在于<strong>更具体</strong>的对象中。<br>Object的每个实例都具有下列属性和方法。</p>
<table>
<thead>
<tr>
<th>属性或方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>constructor(属性)</td>
<td>保存着用于创建<strong>当前对象</strong>的函数</td>
</tr>
<tr>
<td>hasOwnProperty(propertyName)</td>
<td>检查给定的<strong>属性</strong>在<em>当前对象**</em>实例**中是否存在。<br>propertyName必须是String类型。</td>
</tr>
<tr>
<td>isPrototypeof(object)</td>
<td>检查传入的对象是否是<strong>当前对象</strong>的原型</td>
</tr>
<tr>
<td>propertyIsEnumerable(prototyName)</td>
<td>给定的<strong>属性</strong>是否能够使用for-in来<strong>枚举</strong><br>propertyName必须是String类型。</td>
</tr>
<tr>
<td>toLocaleString()</td>
<td>返回对象的String表示，与执行环境对应</td>
</tr>
<tr>
<td>toStirng()</td>
<td>返回对象的Sting表示</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回对象的Sting、Number或者Boolean表示。一般和toString()方法返回值相同</td>
</tr>
</tbody>
</table>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/26/ES6-Destructuring/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="踽踽前行的路人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/26/ES6-Destructuring/" itemprop="url">变量的解构赋值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-26T16:19:07+08:00">
                2017-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index">
                    <span itemprop="name">ES6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<h1 id="数组的解构赋值"><a href="#数组的解构赋值" class="headerlink" title="数组的解构赋值"></a>数组的解构赋值</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>ES6 允许按照一定<strong>模式</strong>，从<em>数组</em>和<em>对象</em>中提<strong>取</strong>值，对变量进行赋值，这被称为解构（Destructuring）。<br>以前，对一个变量赋值只能<strong>直接赋值</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> a = array[<span class="number">0</span>];</div><div class="line"><span class="keyword">var</span> b = array[<span class="number">1</span>];</div><div class="line"><span class="keyword">var</span> c = array[<span class="number">2</span>];</div></pre></td></tr></table></figure></p>
<p>ES6利用Destructuring对变量赋值就可以减少很多冗余代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> [a,b,c] = array;</div></pre></td></tr></table></figure></p>
<p>上述代码表示，从数组中<strong>提取</strong>，按照对应的<strong>位置</strong>，对变量进行赋值。</p>
<blockquote>
<p>本质上，这种写法属于<strong>“模式匹配”</strong>，只要等号两边的<em>模式</em>相同，左边的变量就会被赋予<em>对应</em>的值</p>
</blockquote>
<p>这点可以对比一下RegExp的<em>模式匹配</em></p>
<blockquote>
<p>正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用作按照“给定模式”匹配文本的工具。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//先从一个简单的例子说起</span></div><div class="line">/cat/.test(<span class="string">'cats and dogs'</span>)<span class="comment">//true</span></div><div class="line"><span class="comment">//该示例中**模式**(/cat/)来检查变量'cats and dogs'中是否存在能够匹配模式的文本，示例中String中的cat能够匹配模式/cat/，test的结果为true</span></div></pre></td></tr></table></figure>
<p>下面是解构赋值的常规示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//该示例中，模式匹配是根据数据的*等级*，foo对应需要处理数组的最外层，以此类推，bar为第二层</span></div><div class="line"><span class="keyword">let</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</div><div class="line">foo <span class="comment">// 1</span></div><div class="line">bar <span class="comment">// 2</span></div><div class="line">baz <span class="comment">// 3</span></div><div class="line"><span class="comment">//该示例中变量中只有third是存在的，所以只对third进行对应的赋值</span></div><div class="line"><span class="keyword">let</span> [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</div><div class="line">third <span class="comment">// "baz"</span></div><div class="line"><span class="comment">//道理同上</span></div><div class="line"><span class="keyword">let</span> [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 3</span></div><div class="line"><span class="comment">//note:在解构赋值中...代表的是，将待处理数组中剩余的变量存放到一个数组中。</span></div><div class="line"><span class="keyword">let</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line">head <span class="comment">// 1</span></div><div class="line">tail <span class="comment">// [2, 3, 4]</span></div><div class="line"><span class="comment">//note：这里需要注意两点1:对于没有匹配成功的变量，值为undefined </span></div><div class="line"><span class="comment">//2：在待处理数组中没有剩余的值进行匹配，同时在解构中使用了...之后，...之后的变量为[]</span></div><div class="line"><span class="keyword">let</span> [x, y, ...z] = [<span class="string">'a'</span>];</div><div class="line">x <span class="comment">// "a"</span></div><div class="line">y <span class="comment">// undefined</span></div><div class="line">z <span class="comment">// []</span></div></pre></td></tr></table></figure></p>
<h2 id="不完全解构"><a href="#不完全解构" class="headerlink" title="不完全解构"></a>不完全解构</h2><blockquote>
<p>不完全解构：等号左边的模式，只匹配<strong>一部分</strong>的等号右边的数组</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 2</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</div><div class="line">a <span class="comment">// 1</span></div><div class="line">b <span class="comment">// 2</span></div><div class="line">d <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<h2 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h2><p>解构赋值允许指定默认值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</div><div class="line">foo <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></div><div class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>ES6 内部使用<strong>严格相等</strong>运算符（===），判断一个位置是否有值。所以，如果一个数组成员<em>不严格等于**</em>undefined<strong>，默认值是不会生效的。<br>默认值可以引用解构赋值的其他变量，但该变量必须</strong>已经声明**。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [];     <span class="comment">// x=1; y=1</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">2</span>];    <span class="comment">// x=2; y=2</span></div><div class="line"><span class="keyword">let</span> [x = <span class="number">1</span>, y = x] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x=1; y=2</span></div><div class="line"><span class="keyword">let</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">// ReferenceError </span></div><div class="line"><span class="keyword">var</span> [x = y, y = <span class="number">1</span>] = [];     <span class="comment">//x= undefined; y= 1;</span></div></pre></td></tr></table></figure></p>
</blockquote>
<p>对于上面的示例需要特别注意两点</p>
<ol>
<li>示例中前三个例子原理都是一样的，按照浏览器处理方式，先用let 声明了<strong>x</strong>，然后再声明<strong>y</strong>，然后根据解构规则，在=右边严格等于undefined默认值值生效，其余都是按照匹配模式处理。</li>
<li>对于第四个例子中，在进行编译的时出错，其实这和解构没有任何关系，在介绍let的时候，let 定义的变量存在TDZ(暂时性死区)，由1解析可知，x先于y定义，但是在对x处理默认值的时候，先于y定义调用了y。所以会报错。</li>
</ol>
<h1 id="对象的解构赋值"><a href="#对象的解构赋值" class="headerlink" title="对象的解构赋值"></a>对象的解构赋值</h1><p><strong>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//变量和对象中属性次序不同</span></div><div class="line"><span class="keyword">let</span> &#123; bar, foo &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">foo <span class="comment">// "aaa"</span></div><div class="line">bar <span class="comment">// "bbb"</span></div><div class="line"><span class="comment">//变量没有匹配到对象中的变量名，所以没有匹配成功</span></div><div class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">baz <span class="comment">// undefined</span></div></pre></td></tr></table></figure></p>
<p>如果变量名与属性名不一致，必须在<strong>模式</strong>中特意匹配对象的<em>格式</em><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//在模式中变量为baz,但是在匹配对象中没有baz这个属性，所以需要在模式中特意构造出对象中对应的属性</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">'aaa'</span>, <span class="attr">bar</span>: <span class="string">'bbb'</span> &#125;;</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">first</span>: <span class="string">'hello'</span>, <span class="attr">last</span>: <span class="string">'world'</span> &#125;;</div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">first</span>: f, <span class="attr">last</span>: l &#125; = obj;</div><div class="line">f <span class="comment">// 'hello'</span></div><div class="line">l <span class="comment">// 'world'</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">foo</span>: baz &#125; = &#123; <span class="attr">foo</span>: <span class="string">"aaa"</span>, <span class="attr">bar</span>: <span class="string">"bbb"</span> &#125;;</div><div class="line">baz <span class="comment">// "aaa"</span></div><div class="line">foo <span class="comment">// error: foo is not defined</span></div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</div><div class="line">x <span class="comment">// 3</span></div><div class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;;</div><div class="line">x <span class="comment">// 1</span></div><div class="line">y <span class="comment">// 5</span></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;&#125;;</div><div class="line">y <span class="comment">// 3</span></div><div class="line"><span class="keyword">var</span> &#123;<span class="attr">x</span>: y = <span class="number">3</span>&#125; = &#123;<span class="attr">x</span>: <span class="number">5</span>&#125;;</div><div class="line">y <span class="comment">// 5</span></div><div class="line"><span class="keyword">var</span> &#123; <span class="attr">message</span>: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</div><div class="line">msg <span class="comment">// "Something went wrong"</span></div></pre></td></tr></table></figure>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</div></pre></td></tr></table></figure></p>
<h1 id="其他数据类型的解构赋值"><a href="#其他数据类型的解构赋值" class="headerlink" title="其他数据类型的解构赋值"></a>其他数据类型的解构赋值</h1><p>在这里需要明确一下，对于ES5来说，共有6中数据类型(ES6,新增了Symbol类型)</p>
<ul>
<li>数值（number）：整数和小数（比如1和3.14）</li>
<li>字符串（string）：字符组成的文本（比如”Hello World”）</li>
<li>布尔值（boolean）：true（真）和false（假）两个特定值</li>
<li>undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值</li>
<li>null：表示无值，即此处的值就是“无”的状态。</li>
<li>对象（object）：各种值组成的集合</li>
</ul>
<p>上面讨论了针对Array(属于对象类型)、普通对象的解构赋值，但是对于解构赋值来说，也同样适用于其他的数据类型。(除了undefined/null)</p>
<blockquote>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
</blockquote>
<p>对于其他的数据类型的解构赋值，其实都是先将=右边的数据转换为<strong>对象</strong>,然后根据各自转为对象的一些特性进行解构处理。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//示例1</span></div><div class="line"><span class="keyword">const</span> [a, b, c, d, e] = <span class="string">'hello'</span>;</div><div class="line">a <span class="comment">// "h"</span></div><div class="line">b <span class="comment">// "e"</span></div><div class="line">c <span class="comment">// "l"</span></div><div class="line">d <span class="comment">// "l"</span></div><div class="line">e <span class="comment">// "o"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">length</span> : len&#125; = <span class="string">'hello'</span>;</div><div class="line">len <span class="comment">// 5</span></div><div class="line"><span class="comment">//示例2</span></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="number">123</span>;</div><div class="line">s === <span class="built_in">Number</span>.prototype.toString <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123;<span class="attr">toString</span>: s&#125; = <span class="literal">true</span>;</div><div class="line">s === <span class="built_in">Boolean</span>.prototype.toString <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<p>针对示例1来说，浏览器处理过程如下</p>
<ol>
<li>let source = new Object(‘hello’);//soucre:{0:”h”,1:”e”,2:”l”,3:”l”,4:”o”,length:5}</li>
<li>const [a,b,c,d,e] = source;</li>
</ol>
<h1 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h1><p>ES6的出现就是为了解决ES5的一些痛点，或者是减少代码的冗余量。</p>
<h2 id="交换变量的值"><a href="#交换变量的值" class="headerlink" title="交换变量的值"></a>交换变量的值</h2><p>先看一下ES5进行变量值的交互(引用第三个变量的方式就不描述了，太LOW了)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//ES5两个变量就行交互</span></div><div class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</div><div class="line"><span class="keyword">var</span> b = <span class="number">99</span>;</div><div class="line">a ^= b, b ^= a, a ^= b;</div><div class="line">a <span class="comment">// 99</span></div><div class="line">b <span class="comment">// 10</span></div></pre></td></tr></table></figure></p>
<p>相比较，采用解构赋值简直简单到死。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</div><div class="line"></div><div class="line">[x, y] = [y, x];</div></pre></td></tr></table></figure></p>
<h2 id="从函数返回多个值"><a href="#从函数返回多个值" class="headerlink" title="从函数返回多个值"></a>从函数返回多个值</h2><p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 返回一个数组</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> [a, b, c] = example();</div><div class="line"><span class="comment">// 返回一个对象</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    foo: <span class="number">1</span>,</div><div class="line">    bar: <span class="number">2</span></div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</div></pre></td></tr></table></figure></p>
<h2 id="函数参数的定义"><a href="#函数参数的定义" class="headerlink" title="函数参数的定义"></a>函数参数的定义</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数是一组有次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">[x, y, z]</span>) </span>&#123; ... &#125;</div><div class="line">f([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</div><div class="line"><span class="comment">// 参数是一组无次序的值</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</div><div class="line">f(&#123;<span class="attr">z</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">2</span>, <span class="attr">x</span>: <span class="number">1</span>&#125;);</div></pre></td></tr></table></figure>
<h2 id="提取-JSON-数据"><a href="#提取-JSON-数据" class="headerlink" title="提取 JSON 数据"></a>提取 JSON 数据</h2><p>解构赋值对提取 JSON 对象中的数据，尤其有用<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> jsonData = &#123;</div><div class="line">  id: <span class="number">42</span>,</div><div class="line">  status: <span class="string">"OK"</span>,</div><div class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; id, status, <span class="attr">data</span>: number &#125; = jsonData;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(id, status, number);</div><div class="line"><span class="comment">// 42, "OK", [867, 5309]</span></div></pre></td></tr></table></figure></p>
<h2 id="函数参数的默认值"><a href="#函数参数的默认值" class="headerlink" title="函数参数的默认值"></a>函数参数的默认值</h2><p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> (<span class="params">url, &#123;</span></span></div><div class="line"><span class="function"><span class="params">  async = true,</span></span></div><div class="line"><span class="function"><span class="params">  beforeSend = function (</span>) </span>&#123;&#125;,</div><div class="line">  cache = <span class="literal">true</span>,</div><div class="line">  complete = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;,</div><div class="line">  crossDomain = <span class="literal">false</span>,</div><div class="line">  global = <span class="literal">true</span>,</div><div class="line">  <span class="comment">// ... more config</span></div><div class="line">&#125;) &#123;</div><div class="line">  <span class="comment">// ... do stuff</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h2 id="遍历-Map-结构"><a href="#遍历-Map-结构" class="headerlink" title="遍历 Map 结构"></a>遍历 Map 结构</h2><p>任何部署了 <strong>Iterator</strong> 接口的对象，都可以用<strong>for…of</strong>循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line">map.set(<span class="string">'first'</span>, <span class="string">'hello'</span>);</div><div class="line">map.set(<span class="string">'second'</span>, <span class="string">'world'</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// first is hello</span></div><div class="line"><span class="comment">// second is world</span></div></pre></td></tr></table></figure></p>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取键名</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 获取键值</span></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123;</div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="输入模块的指定方法"><a href="#输入模块的指定方法" class="headerlink" title="输入模块的指定方法"></a>输入模块的指定方法</h2><p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。尤其在React进行开发的时候尤其有用。</p>
<pre><code class="js"><span class="keyword">import</span> React, {Component} <span class="keyword">from</span> <span class="string">'react'</span>;
<span class="keyword">import</span> {connect} <span class="keyword">from</span> <span class="string">'react-redux'</span>;
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/25/React-JSX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="踽踽前行的路人">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="朝花夕拾">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/25/React-JSX/" itemprop="url">JSX解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-25T16:18:22+08:00">
                2017-12-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>在介绍JSX之前，需要回顾一下JS在处理页面事件时扮演的什么角色。<br>JS在处理页面各种事件时，无非就是利用DOM提供的API使JS有能力对HTML事件作出反应。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></div><div class="line"><span class="javascript">            <span class="function"><span class="keyword">function</span> <span class="title">handleButonClick</span>(<span class="params">e</span>)</span>&#123;</span></div><div class="line"><span class="javascript">                e.innerText = <span class="string">'你说的对'</span>;</span></div><div class="line"><span class="undefined">            &#125;</span></div><div class="line"><span class="undefined">        </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">"handleButonClick(this)"</span>&gt;</span>我是一个萌萌哒的汉子<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>从上面的例子中看到,JS是利用DOM提供的API来对页面事件进行控制，其中Function在里面扮演着很重要的角色。<br>明白了这点，介绍JSX其实就有点简单了。<br>首先需要明确的一点就是React是JS的一个<strong>工具库</strong>。何为工具库，就是为了简化JS对页面的操作产生的。</p>
<h1 id="初识JSX"><a href="#初识JSX" class="headerlink" title="初识JSX"></a>初识JSX</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>人家是一个JSX变量哦！<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<p>上面从JS的角度来分析，就是定义了一个常量(element)，保存着<div>人家是一个JSX变量哦！</div>。你会发现和ES5，ES6定义变量的方式，有点别扭。其实长这样的定义变量的方式，就是JSX语法。</p>
<blockquote>
<p>JSX：a syntax extension to JavaScript</p>
</blockquote>
<p>JSX其实就是对JS的语法扩展，说的更透彻一点就是对ECMAScript的语法扩展。在JSX中,就是将<strong>HTML语言直接写在JS语言中，不加任何引号</strong>。用于来<strong>描述</strong>页面长什么样子。利用HTML可以更好的描述页面的各种<em>层级结构</em>。</p>
<h1 id="在JSX中嵌入表达式"><a href="#在JSX中嵌入表达式" class="headerlink" title="在JSX中嵌入表达式"></a>在JSX中嵌入表达式</h1><blockquote>
<p>You can embed any JavaScript expression in JSX by wrapping it in curly braces.(你可以通过在JSX利用大括号嵌入任何JS表达式)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> param = <span class="string">"一人我饮酒醉"</span>;</div><div class="line"><span class="keyword">const</span> elemnt = <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;param&#125; "醉把佳人成双对"<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
<h1 id="JSX也可以作为表达式使用"><a href="#JSX也可以作为表达式使用" class="headerlink" title="JSX也可以作为表达式使用"></a>JSX也可以作为表达式使用</h1><p>需要明确的<strong>知识点</strong>：JS是有一半的”基因”是面向对象语言，所以JS中处处是对象。<br>由于JSX是对JS的语法扩展，所以JSX也是可以作为表达式存在的。(经过特定的编译器，JSX expressions会被编译为普通函数用于调用或者是JS Object)。<br>这就意味着，你可以在if 或者for循环中使用JSX。用于将JSX赋值给一个变量，作为函数参数使用（HOC）或者作为函数的返回值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (user) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h1 id="JSX中指定属性"><a href="#JSX中指定属性" class="headerlink" title="JSX中指定属性"></a>JSX中指定属性</h1><ol>
<li><p>可以使用<strong>引号</strong>(“ “)为React Element中某个<strong>属性</strong>指定一个字符串变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"abc"</span>&gt;</span>呵呵<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></div></pre></td></tr></table></figure>
</li>
<li><p>将属性值嵌入到<strong>大括号</strong>中为React Element属性赋值</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</div></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="JSX-Represents-Objects"><a href="#JSX-Represents-Objects" class="headerlink" title="JSX Represents Objects"></a>JSX Represents Objects</h1><p>上文了解到JSX是js的一个语法扩展，也就是说，没有进过转换或者编译的JSX元素，浏览器是不认识的。所以在页面的编译阶段，当遇到用JSX语法来构建的element的时候，React内部会在内部调用React.createElement()将JSX变成一个浏览器能够识别的<strong>普通对象</strong>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//JSX构建元素</span></div><div class="line"><span class="keyword">const</span> element = (</div><div class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</div><div class="line">    Hello, world!</div><div class="line">  &lt;<span class="regexp">/h1&gt;</span></div><div class="line"><span class="regexp">);</span></div><div class="line"><span class="regexp">/</span><span class="regexp">/不使用JSX,直接调用createElement来构建Element</span></div><div class="line"><span class="regexp">const element = React.createElement(</span></div><div class="line"><span class="regexp">  'h1',</span></div><div class="line"><span class="regexp">  &#123;className: 'greeting'&#125;,</span></div><div class="line"><span class="regexp">  'Hello, world!'</span></div><div class="line"><span class="regexp">);</span></div></pre></td></tr></table></figure></p>
<p>上面两种方式构建的Element是等价的。最后的结果都是构建了一个具有<strong>层级结构</strong>的element。<br>最后经过编译阶段，利用JSX构建的React元素会被编译成普通对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这里是进过简化过的，具体的对象比这个复杂。</span></div><div class="line"><span class="keyword">const</span> element = &#123;</div><div class="line">  type: <span class="string">'h1'</span>,</div><div class="line">  props: &#123;</div><div class="line">    className: <span class="string">'greeting'</span>,</div><div class="line">    children: <span class="string">'Hello, world'</span></div><div class="line">  &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<h1 id="Buzzer"><a href="#Buzzer" class="headerlink" title="Buzzer"></a>Buzzer</h1><p>其实在React开发过程中完全可以抛弃JSX来进行页面的构建，利用React.createElement()来构建页面也是可以的，但是大多数人还是更愿意采用JSX。</p>
<ol>
<li>JSX类似于用HTML来搭建页面，<strong>所见即所得</strong></li>
<li>JSX语法能够实现代码的高内聚低耦合</li>
<li>使用JSX可以显示React更多的有用的错误提示</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="踽踽前行的路人" />
            
              <p class="site-author-name" itemprop="name">踽踽前行的路人</p>
              <p class="site-description motion-element" itemprop="description">天道酬勤</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/fanxiaowei" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
            
          </div>

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://theme-next.iissnan.com/getting-started.html" title="利用hexo构建个人博客" target="_blank">利用hexo构建个人博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://doc.react-china.org" title="React中文官网" target="_blank">React中文官网</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.w3schools.com/css/css_intro.asp" title="css 英文官网" target="_blank">css 英文官网</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://es6.ruanyifeng.com/" title="Es6教程" target="_blank">Es6教程</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">踽踽前行的路人</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  



  
  





  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/three.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_lines.min.js"></script>
  

  
  
    <script type="text/javascript" src="/lib/three/canvas_sphere.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  
  

  

  

  

</body>
</html>
